
==================== FINAL INTERFACE ====================
2018-11-05 09:10:41.011539971 UTC

interface appm-0.0.0-bBoXP3Z3yF8cAWvQVfHOK:SolverImpl 8043
  interface hash: 2b867556e574a232c2e546550325905c
  ABI hash: 37041eaf1b368993062e4573a24ebe9f
  export-list hash: b14ad8efd8fc0be1c10afc3210690d01
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 1f596daf84c7527444ae092b33472386
  opt_hash: 14e536840aca4e889cad654e6f9b79c1
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  sig of: Nothing
  used TH splices: False
  where
exports:
  SolverImpl.equiv
  SolverImpl.execSolver
  SolverImpl.get
  SolverImpl.getPkgs
  SolverImpl.getSols
  SolverImpl.groupByName
  SolverImpl.inSol
  SolverImpl.install
  SolverImpl.isRequired
  SolverImpl.normalize
  SolverImpl.normalize'
  SolverImpl.normalize''
  SolverImpl.put
  SolverImpl.quality
  SolverImpl.solve
  SolverImpl.takeIfSat
  SolverImpl.toSol
  SolverImpl.Context
  SolverImpl.Solver{SolverImpl.S runSolver}
module dependencies: Defs Utils
package dependencies: array-0.5.2.0 base-4.11.1.0*
                      containers-0.5.11.0 deepseq-1.4.3.0 ghc-prim-0.5.2.0
                      integer-gmp-1.0.2.0
orphans: base-4.11.1.0:GHC.Float base-4.11.1.0:GHC.Base
family instance modules: base-4.11.1.0:Control.Applicative
                         base-4.11.1.0:Data.Complex base-4.11.1.0:Data.Functor.Compose
                         base-4.11.1.0:Data.Functor.Const
                         base-4.11.1.0:Data.Functor.Identity
                         base-4.11.1.0:Data.Functor.Product base-4.11.1.0:Data.Functor.Sum
                         base-4.11.1.0:Data.Monoid base-4.11.1.0:Data.Semigroup
                         base-4.11.1.0:Data.Semigroup.Internal base-4.11.1.0:Data.Version
                         base-4.11.1.0:Data.Void base-4.11.1.0:GHC.Exts
                         base-4.11.1.0:GHC.Generics base-4.11.1.0:GHC.IO.Exception
                         containers-0.5.11.0:Data.Map.Internal
                         containers-0.5.11.0:Data.Set.Internal
import  -/  Defs 33704ed0d96c186bd2b1ffcf2d3c5e21
  exports: d483d9f9fac845ad0d3d1b6b82a00958
  Constrs 8c166b6e32f01bcd8bb0027ca3b54fbe
  DB fd707bf94568c6ad957a265ba68e6b24
  Database 72116789c94c7310ad831055c34dc36c
  PName 5f19c9b9fbea2b2b9245083ff941c0d5
  Pkg b4c1d87cd7afe226783959c5cb87dbfc
  Sol 937cea62bc665f23bf865f9bce4039de
  deps b4c1d87cd7afe226783959c5cb87dbfc
  desc b4c1d87cd7afe226783959c5cb87dbfc
  name b4c1d87cd7afe226783959c5cb87dbfc
  ver b4c1d87cd7afe226783959c5cb87dbfc
import  -/  Utils 56e11831633c003055841737133cc50e
  exports: 530081d4b74e471a0e493728d7b6b796
  merge d812c272c54c91bb461d01992a41eec5
  satisfies cfdac64241c4143c94a0b289e5bb6de9
import  -/  base-4.11.1.0:Control.Arrow ce43199b5356a11ee2a8317f0ec30aee
import  -/  base-4.11.1.0:Control.Monad c5f960c67d822497578bffbd3e4c01cf
import  -/  base-4.11.1.0:Data.Either 39d922b371c4c52d426e9ee66de8371a
import  -/  base-4.11.1.0:Data.Foldable 8ed35c38958063956af33c935ea03444
import  -/  base-4.11.1.0:Data.Functor f522c3501272159820fd6f242510732f
import  -/  base-4.11.1.0:Data.List 83dc843e47bfc0c5af51e19c6f3476d5
import  -/  base-4.11.1.0:Data.Maybe 409c3da2b142470b68be39ce1d97a9f7
import  -/  base-4.11.1.0:Data.OldList 1b35aa3c6805ff7c8887a35a866fe006
import  -/  base-4.11.1.0:Data.Ord 8579f16310a4ec69c00617051bb5c3d9
import  -/  base-4.11.1.0:Data.Traversable 7ad4edb9184ea1ae8e73f6b94f115c8c
import  -/  base-4.11.1.0:Data.Tuple 3af66f3ac61ed95ba8a3a3f68ebc5003
import  -/  base-4.11.1.0:GHC.Base 604111500e81281298777e721c75643b
import  -/  base-4.11.1.0:GHC.List 1e4357702d8d00cded0703bd293e50e8
import  -/  base-4.11.1.0:GHC.Num 8e54b26dce4495382dc4b50cf36ab754
import  -/  base-4.11.1.0:GHC.Show 73be67392447c974f19c3befd83c46c0
import  -/  base-4.11.1.0:Prelude 0750c25585e2b797cd78291d423d39dd
import  -/  containers-0.5.11.0:Data.Map f51b9cf04edd738eb6d014be576b3403
import  -/  ghc-prim-0.5.2.0:GHC.Classes 122abfcd7450c6c11602933c9ca5f80d
import  -/  ghc-prim-0.5.2.0:GHC.Types d9b3023de7feae4a5308d643da5543f7
02ffede47e67f7d8fd30284ba86e7a22
  $fApplicativeSolver :: GHC.Base.Applicative SolverImpl.Solver
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ SolverImpl.Solver
                  SolverImpl.$fFunctorSolver
                  SolverImpl.$fApplicativeSolver5
                    `cast`
                  (forall (a :: <*>_N).
                   <a>_R ->_R Sym (SolverImpl.N:Solver[0] <a>_R))
                  SolverImpl.$fApplicativeSolver4
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <SolverImpl.Solver (a -> b)>_R
                   ->_R <SolverImpl.Solver a>_R
                   ->_R Sym (SolverImpl.N:Solver[0] <b>_R))
                  SolverImpl.$fApplicativeSolver3
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
                   <a -> b -> c>_R
                   ->_R <SolverImpl.Solver a>_R
                   ->_R <SolverImpl.Solver b>_R
                   ->_R Sym (SolverImpl.N:Solver[0] <c>_R))
                  SolverImpl.$fApplicativeSolver2
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <SolverImpl.Solver a>_R
                   ->_R <SolverImpl.Solver b>_R
                   ->_R Sym (SolverImpl.N:Solver[0] <b>_R))
                  (\ @ a @ b -> SolverImpl.$fApplicativeSolver1 @ b @ a)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <SolverImpl.Solver a>_R
                   ->_R <SolverImpl.Solver b>_R
                   ->_R Sym (SolverImpl.N:Solver[0] <a>_R)) -}
02ffede47e67f7d8fd30284ba86e7a22
  $fApplicativeSolver1 ::
    SolverImpl.Solver a
    -> SolverImpl.Solver b -> SolverImpl.Context -> (a, [Defs.Sol])
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(U(1*U,1*U))><L,1*C1(U(A,1*U))><S,1*U(U,U)>m,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ b
                   @ a
                   (w :: SolverImpl.Solver a)
                   (w1 :: SolverImpl.Solver b)
                   (w2 :: SolverImpl.Context) ->
                 case w2 of ww { (,) ww1 ww2 ->
                 let {
                   ds :: (a, [Defs.Sol])
                   = w `cast` (SolverImpl.N:Solver[0] <a>_R) (ww1, ww2)
                 } in
                 (case ds of wild { (,) a1 s' -> a1 },
                  case w1 `cast` (SolverImpl.N:Solver[0] <b>_R)
                         (case ds of wild { (,) a1 s' -> s' }, ww2) of wild { (,) a1 s' ->
                  s' }) }) -}
02ffede47e67f7d8fd30284ba86e7a22
  $fApplicativeSolver2 ::
    SolverImpl.Solver a
    -> SolverImpl.Solver b -> SolverImpl.Context -> (b, [Defs.Sol])
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(U(A,1*U))><L,1*C1(U(1*U,1*U))><S,1*U(U,U)>m,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ b
                   (w :: SolverImpl.Solver a)
                   (w1 :: SolverImpl.Solver b)
                   (w2 :: SolverImpl.Context) ->
                 case w2 of ww { (,) ww1 ww2 ->
                 let {
                   ds :: (b, [Defs.Sol])
                   = w1 `cast` (SolverImpl.N:Solver[0] <b>_R)
                       (case w `cast` (SolverImpl.N:Solver[0] <a>_R)
                               (ww1, ww2) of wild { (,) a1 s' ->
                        s' },
                        ww2)
                 } in
                 (case ds of wild { (,) a1 s' -> a1 },
                  case ds of wild { (,) a1 s' -> s' }) }) -}
02ffede47e67f7d8fd30284ba86e7a22
  $fApplicativeSolver3 ::
    (a -> b -> c)
    -> SolverImpl.Solver a
    -> SolverImpl.Solver b
    -> SolverImpl.Context
    -> (c, [Defs.Sol])
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,1*C1(C1(U))><L,1*C1(U(1*U,1*U))><L,1*C1(U(1*U,1*U))><S,1*U(U,U)>m,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   @ b
                   @ c
                   (w :: a -> b -> c)
                   (w1 :: SolverImpl.Solver a)
                   (w2 :: SolverImpl.Solver b)
                   (w3 :: SolverImpl.Context) ->
                 case w3 of ww { (,) ww1 ww2 ->
                 let {
                   ds :: (a, [Defs.Sol])
                   = w1 `cast` (SolverImpl.N:Solver[0] <a>_R) (ww1, ww2)
                 } in
                 let {
                   ds1 :: (b, [Defs.Sol])
                   = w2 `cast` (SolverImpl.N:Solver[0] <b>_R)
                       (case ds of wild { (,) a1 s' -> s' }, ww2)
                 } in
                 (w (case ds of wild { (,) a1 s' -> a1 })
                    (case ds1 of wild { (,) a1 s' -> a1 }),
                  case ds1 of wild { (,) a1 s' -> s' }) }) -}
02ffede47e67f7d8fd30284ba86e7a22
  $fApplicativeSolver4 ::
    SolverImpl.Solver (a -> b)
    -> SolverImpl.Solver a
    -> ([Defs.Sol], Defs.Database)
    -> (b, [Defs.Sol])
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(U(1*C1(U),1*U))><L,1*C1(U(1*U,1*U))><S,1*U(U,U)>m,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ b
                   (w :: SolverImpl.Solver (a -> b))
                   (w1 :: SolverImpl.Solver a)
                   (w2 :: ([Defs.Sol], Defs.Database)) ->
                 case w2 of ww { (,) ww1 ww2 ->
                 let {
                   ds :: (a -> b, [Defs.Sol])
                   = w `cast` (SolverImpl.N:Solver[0] <a -> b>_R) (ww1, ww2)
                 } in
                 let {
                   ds1 :: (a, [Defs.Sol])
                   = w1 `cast` (SolverImpl.N:Solver[0] <a>_R)
                       (case ds of wild { (,) a1 s' -> s' }, ww2)
                 } in
                 (case ds of wild { (,) a1 s' ->
                  a1 (case ds1 of wild1 { (,) a2 s'1 -> a2 }) },
                  case ds1 of wild { (,) a1 s' -> s' }) }) -}
4d7e0a92e79430ad45b699d606cceaf5
  $fApplicativeSolver5 ::
    a -> ([Defs.Sol], Defs.Database) -> (a, [Defs.Sol])
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U(U,A)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a (a1 :: a) (ds :: ([Defs.Sol], Defs.Database)) ->
                 case ds of wild { (,) s ds1 -> (a1, s) }) -}
02ffede47e67f7d8fd30284ba86e7a22
  $fFunctorSolver :: GHC.Base.Functor SolverImpl.Solver
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ SolverImpl.Solver
                  SolverImpl.$fFunctorSolver2
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <a -> b>_R
                   ->_R <SolverImpl.Solver a>_R
                   ->_R Sym (SolverImpl.N:Solver[0] <b>_R))
                  SolverImpl.$fFunctorSolver1
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <a>_R
                   ->_R <SolverImpl.Solver b>_R
                   ->_R Sym (SolverImpl.N:Solver[0] <a>_R)) -}
02ffede47e67f7d8fd30284ba86e7a22
  $fFunctorSolver1 ::
    a -> SolverImpl.Solver b -> SolverImpl.Context -> (a, [Defs.Sol])
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U><L,1*C1(U(A,1*U))><S,1*U(U,U)>m,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ b
                   (x :: a)
                   (eta :: SolverImpl.Solver b)
                   (eta1 :: SolverImpl.Context) ->
                 case eta1 of wild { (,) s db ->
                 (x,
                  case eta `cast` (SolverImpl.N:Solver[0] <b>_R)
                         (s, db) of wild1 { (,) a1 s' ->
                  s' }) }) -}
02ffede47e67f7d8fd30284ba86e7a22
  $fFunctorSolver2 ::
    (a -> b)
    -> SolverImpl.Solver a
    -> ([Defs.Sol], Defs.Database)
    -> (b, [Defs.Sol])
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(U)><L,1*C1(U(1*U,1*U))><S,1*U(U,U)>m,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ b
                   (f :: a -> b)
                   (m1 :: SolverImpl.Solver a)
                   (ds :: ([Defs.Sol], Defs.Database)) ->
                 case ds of wild { (,) s db ->
                 let {
                   ds1 :: (a, [Defs.Sol])
                   = m1 `cast` (SolverImpl.N:Solver[0] <a>_R) (s, db)
                 } in
                 (f (case ds1 of wild1 { (,) a1 s' -> a1 }),
                  case ds1 of wild1 { (,) a1 s' -> s' }) }) -}
02ffede47e67f7d8fd30284ba86e7a22
  $fMonadSolver :: GHC.Base.Monad SolverImpl.Solver
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ SolverImpl.Solver
                  SolverImpl.$fApplicativeSolver
                  SolverImpl.$fMonadSolver1
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <SolverImpl.Solver a>_R
                   ->_R <a -> SolverImpl.Solver b>_R
                   ->_R Sym (SolverImpl.N:Solver[0] <b>_R))
                  SolverImpl.$fMonadSolver_$c>>
                  SolverImpl.$fApplicativeSolver5
                    `cast`
                  (forall (a :: <*>_N).
                   <a>_R ->_R Sym (SolverImpl.N:Solver[0] <a>_R))
                  (\ @ a ->
                   GHC.Err.errorWithoutStackTrace
                     @ 'GHC.Types.LiftedRep
                     @ (SolverImpl.Solver a)) -}
02ffede47e67f7d8fd30284ba86e7a22
  $fMonadSolver1 ::
    SolverImpl.Solver a
    -> (a -> SolverImpl.Solver b)
    -> ([Defs.Sol], Defs.Database)
    -> (b, [Defs.Sol])
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(U(1*U,1*U))><C(C(S)),1*C1(C1(U(U,U)))><S,1*U(U,U)>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ b
                   (w :: SolverImpl.Solver a)
                   (w1 :: a -> SolverImpl.Solver b)
                   (w2 :: ([Defs.Sol], Defs.Database)) ->
                 case w2 of ww { (,) ww1 ww2 ->
                 SolverImpl.$w$c>>= @ a @ b w w1 ww1 ww2 }) -}
02ffede47e67f7d8fd30284ba86e7a22
  $fMonadSolver_$c>> ::
    SolverImpl.Solver a -> SolverImpl.Solver b -> SolverImpl.Solver b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(U(A,1*U))><C(S),1*C1(U(U,U))><S,1*U(U,U)>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ a
                   @ b
                   (m1 :: SolverImpl.Solver a)
                   (k :: SolverImpl.Solver b)
                   (ds :: ([Defs.Sol], Defs.Database)) ->
                 case ds of wild { (,) s db ->
                 k `cast` (SolverImpl.N:Solver[0] <b>_R)
                   (case m1 `cast` (SolverImpl.N:Solver[0] <a>_R)
                           (s, db) of wild1 { (,) a1 s' ->
                    s' },
                    db) })
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <SolverImpl.Solver a>_R
                 ->_R <SolverImpl.Solver b>_R
                 ->_R Sym (SolverImpl.N:Solver[0] <b>_R)) -}
d61a1189aa01c4d9ba38d237335ca776
  $tc'S :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1493796242501881039##
                   10607428758953102260##
                   SolverImpl.$trModule
                   SolverImpl.$tc'S2
                   1#
                   SolverImpl.$tc'S1) -}
c4cc6f17be122c2e94aea8d2a986ef05
  $tc'S1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
91e4304a92e60391449d64ad2a4d2c92
  $tc'S2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SolverImpl.$tc'S3) -}
fadd81106b49ef97147b1b473b92663a
  $tc'S3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'S"#) -}
a227f4e014e551d36176a8f00f5c856a
  $tcSolver :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10983665504979644480##
                   374953844092403280##
                   SolverImpl.$trModule
                   SolverImpl.$tcSolver1
                   0#
                   GHC.Types.krep$*Arr*) -}
0fb4c5cea594608a4dc000798d310be0
  $tcSolver1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SolverImpl.$tcSolver2) -}
46a90f24ada40d487cfa0569af91b8df
  $tcSolver2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Solver"#) -}
46ada7d316b2690a9dedeaeb15c72c03
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   SolverImpl.$trModule3
                   SolverImpl.$trModule1) -}
2b496187be397a7b9fb55be863b3a236
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SolverImpl.$trModule2) -}
a6721d666c419e4e72035eef72e238a0
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("SolverImpl"#) -}
29615d7922dc86e6efaf238df7890ff8
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SolverImpl.$trModule4) -}
79d563bcb3135fcfc4d266598293883e
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("appm-0.0.0-bBoXP3Z3yF8cAWvQVfHOK"#) -}
02ffede47e67f7d8fd30284ba86e7a22
  $w$c>>= ::
    SolverImpl.Solver a
    -> (a -> SolverImpl.Solver b)
    -> [Defs.Sol]
    -> Defs.Database
    -> (b, [Defs.Sol])
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,1*C1(U(1*U,1*U))><C(C(S)),1*C1(C1(U(U,U)))><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ b
                   (w :: SolverImpl.Solver a)
                   (w1 :: a -> SolverImpl.Solver b)
                   (ww :: [Defs.Sol])
                   (ww1 :: Defs.Database) ->
                 let {
                   ds :: (a, [Defs.Sol])
                   = w `cast` (SolverImpl.N:Solver[0] <a>_R) (ww, ww1)
                 } in
                 (w1 (case ds of wild { (,) a1 s' -> a1 }))
                   `cast`
                 (SolverImpl.N:Solver[0] <b>_R)
                   (case ds of wild { (,) a1 s' -> s' }, ww1)) -}
514174b02b599373f6d3400d3a9efa1b
  $wequiv ::
    GHC.Base.String
    -> Defs.Constrs
    -> GHC.Base.String
    -> Defs.Constrs
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U><S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Base.String)
                   (ww1 :: Defs.Constrs)
                   (ww2 :: GHC.Base.String)
                   (ww3 :: Defs.Constrs) ->
                 case GHC.Base.eqString ww ww2 of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> GHC.Classes.$fEq[]_$c==
                        @ (Defs.PName, Defs.PConstr)
                        Defs.$fEqPkg_$s$fEq(,)
                        (Data.OldList.sortBy
                           @ (Defs.PName, Defs.PConstr)
                           SolverImpl.equiv1
                           ww1)
                        (Data.OldList.sortBy
                           @ (Defs.PName, Defs.PConstr)
                           SolverImpl.equiv1
                           ww3) }) -}
32913649de580f785e12a556bbfd51da
  $wgo2 ::
    [(Defs.PName, Defs.Version)]
    -> [(Defs.PName, Defs.Version)]
    -> GHC.Integer.Type.Integer
    -> GHC.Integer.Type.Integer
    -> GHC.Types.Ordering
  {- Arity: 4, Strictness: <S,1*U><L,1*U><S,U><S,U>, Inline: [0] -}
390c3db81fc92927118755568d229852
  $wlvl ::
    Defs.PName
    -> (GHC.Types.Bool, Defs.Version, Defs.Version)
    -> Defs.PName
    -> (GHC.Types.Bool, Defs.Version, Defs.Version)
    -> GHC.Types.Ordering
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U(1*U,1*U,1*U)><S,1*U><L,1*U(1*U,1*U,1*U)>,
     Inline: [0],
     Unfolding: (\ (ww :: Defs.PName)
                   (ww1 :: (GHC.Types.Bool, Defs.Version, Defs.Version))
                   (ww2 :: Defs.PName)
                   (ww3 :: (GHC.Types.Bool, Defs.Version, Defs.Version)) ->
                 case GHC.Classes.$fOrd[]_$s$ccompare1
                        ww `cast` (Defs.N:PName[0])
                        ww2 `cast` (Defs.N:PName[0]) of wild {
                   GHC.Types.LT -> GHC.Types.LT
                   GHC.Types.EQ
                   -> case ww1 of ww4 { (,,) ww5 ww6 ww7 ->
                      case ww3 of ww8 { (,,) ww9 ww10 ww11 ->
                      let {
                        $j1 :: GHC.Types.Ordering <join 0>
                        = case GHC.Classes.$fOrd[]_$ccompare
                                 @ Defs.VNum
                                 Defs.$fOrdVNum
                                 ww6 `cast` (Defs.N:Version[0])
                                 ww10 `cast` (Defs.N:Version[0]) of wild1 {
                            GHC.Types.LT -> GHC.Types.LT
                            GHC.Types.EQ
                            -> GHC.Classes.$fOrd[]_$ccompare
                                 @ Defs.VNum
                                 Defs.$fOrdVNum
                                 ww7 `cast` (Defs.N:Version[0])
                                 ww11 `cast` (Defs.N:Version[0])
                            GHC.Types.GT -> GHC.Types.GT }
                      } in
                      case ww5 of wild1 {
                        GHC.Types.False
                        -> case ww9 of wild2 {
                             GHC.Types.False -> $j1 GHC.Types.True -> GHC.Types.LT }
                        GHC.Types.True
                        -> case ww9 of wild2 {
                             GHC.Types.False -> GHC.Types.GT GHC.Types.True -> $j1 } } } }
                   GHC.Types.GT -> GHC.Types.GT }) -}
93177d3bc529788d81d2f5894fb0d11a
  $wlvl1 ::
    Defs.PName
    -> Defs.Version -> Defs.PName -> Defs.Version -> GHC.Types.Ordering
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U><S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ (ww :: Defs.PName)
                   (ww1 :: Defs.Version)
                   (ww2 :: Defs.PName)
                   (ww3 :: Defs.Version) ->
                 case GHC.Classes.$fOrd[]_$s$ccompare1
                        ww `cast` (Defs.N:PName[0])
                        ww2 `cast` (Defs.N:PName[0]) of wild {
                   GHC.Types.LT -> GHC.Types.LT
                   GHC.Types.EQ
                   -> GHC.Classes.$fOrd[]_$ccompare
                        @ Defs.VNum
                        Defs.$fOrdVNum
                        ww1 `cast` (Defs.N:Version[0])
                        ww3 `cast` (Defs.N:Version[0])
                   GHC.Types.GT -> GHC.Types.GT }) -}
fe8b4cc43c9bd181a03672738240b80e
  $wtakeIfSat ::
    [Defs.Pkg]
    -> Defs.Constrs
    -> Defs.Sol
    -> GHC.Base.Maybe (Defs.Constrs, Defs.Sol)
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><S,U><L,1*U>,
     Inline: [0],
     Unfolding: (\ (w :: [Defs.Pkg])
                   (ww :: Defs.Constrs)
                   (ww1 :: Defs.Sol) ->
                 let {
                   newsol :: [(Defs.PName, Defs.Version)]
                   = GHC.Base.++
                       @ (Defs.PName, Defs.Version)
                       ww1
                       (GHC.Base.map
                          @ Defs.Pkg
                          @ (Defs.PName, Defs.Version)
                          SolverImpl.takeIfSat1
                          w)
                 } in
                 let {
                   exit :: GHC.Base.Maybe (Defs.Constrs, Defs.Sol) <join 0>
                   = let {
                       exit1 :: Defs.Constrs -> GHC.Base.Maybe (Defs.Constrs, Defs.Sol)
                         <join 1> {- Arity: 1, Strictness: <L,U> -}
                       = \ (eta :: Defs.Constrs)[OneShot] ->
                         GHC.Base.Just
                           @ (Defs.Constrs, [(Defs.PName, Defs.Version)])
                           (eta, newsol)
                     } in
                     letrec {
                       go1 :: [Defs.Pkg]
                              -> Defs.Constrs -> GHC.Base.Maybe (Defs.Constrs, Defs.Sol)
                         <join 2> {- Arity: 2, Strictness: <S,1*U><L,U> -}
                       = \ (ds :: [Defs.Pkg]) (eta :: Defs.Constrs) ->
                         case ds of wild {
                           [] -> exit1 eta
                           : y ys
                           -> case Utils.merge
                                     eta
                                     (case y of wild1 { Defs.Pkg ds4 ds5 ds6 ds7 ->
                                      ds7 }) of wild1 {
                                GHC.Base.Nothing -> GHC.Base.Nothing @ (Defs.Constrs, Defs.Sol)
                                GHC.Base.Just x -> go1 ys x } }
                     } in
                     go1 w ww
                 } in
                 letrec {
                   go1 :: [(Defs.PName, Defs.PConstr)]
                          -> GHC.Base.Maybe (Defs.Constrs, Defs.Sol)
                     <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [(Defs.PName, Defs.PConstr)]) ->
                     case ds of wild {
                       [] -> exit
                       : y ys
                       -> case y of ww2 { (,) ww3 ww4 ->
                          case ww4 of ww5 { (,,) ww6 ww7 ww8 ->
                          case Utils.$wsatisfies' newsol ww3 ww6 ww7 ww8 of wild1 {
                            GHC.Types.False -> GHC.Base.Nothing @ (Defs.Constrs, Defs.Sol)
                            GHC.Types.True -> go1 ys } } } }
                 } in
                 go1 ww) -}
a87c34b5bf10d9d11117e5a9eeade7dd
  type Context = ([Defs.Sol], Defs.Database)
02ffede47e67f7d8fd30284ba86e7a22
  newtype Solver a
    = S {runSolver :: SolverImpl.Context -> (a, [Defs.Sol])}
976e9916bb034c3602282972ffcebae4
  equiv :: Defs.Pkg -> Defs.Pkg -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LLSL),1*U(A,A,1*U,1*U)><S(LLSL),1*U(A,A,1*U,1*U)>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Defs.Pkg) (w1 :: Defs.Pkg) ->
                 case w of ww { Defs.Pkg ww1 ww2 ww3 ww4 ->
                 case w1 of ww5 { Defs.Pkg ww6 ww7 ww8 ww9 ->
                 SolverImpl.$wequiv ww3 ww4 ww8 ww9 } }) -}
c35e7f42c3679c59694110f32d94936e
  equiv1 ::
    (Defs.PName, (GHC.Types.Bool, Defs.Version, Defs.Version))
    -> (Defs.PName, (GHC.Types.Bool, Defs.Version, Defs.Version))
    -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U,1*U(1*U,1*U,1*U))><S(SL),1*U(1*U,1*U(1*U,1*U,1*U))>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: (Defs.PName,
                          (GHC.Types.Bool, Defs.Version, Defs.Version)))
                   (w1 :: (Defs.PName,
                           (GHC.Types.Bool, Defs.Version, Defs.Version))) ->
                 case w of ww { (,) ww1 ww2 ->
                 case w1 of ww3 { (,) ww4 ww5 ->
                 SolverImpl.$wlvl ww1 ww2 ww4 ww5 } }) -}
97eba18283850c5b066732f122e81e37
  execSolver ::
    SolverImpl.Solver a -> SolverImpl.Context -> [Defs.Sol]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <C(S(LS)),1*C1(U(A,1*U))><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a (act :: SolverImpl.Solver a) (x :: SolverImpl.Context) ->
                 case act `cast` (SolverImpl.N:Solver[0] <a>_R)
                        x of wild { (,) ds1 y ->
                 y }) -}
83375d66da7bad74f930b5bba10ba8d7
  get :: SolverImpl.Solver Defs.Database
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U,U)>m,
     Unfolding: InlineRule (0, True, True)
                SolverImpl.get1
                  `cast`
                (Sym (SolverImpl.N:Solver[0] <Defs.Database>_R)) -}
863dab9b41fe3ef4835f6fed4ead7b2a
  get1 :: ([Defs.Sol], Defs.Database) -> (Defs.Database, [Defs.Sol])
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: ([Defs.Sol], Defs.Database)) ->
                 case ds of wild { (,) s db -> (db, s) }) -}
a888b7ae0fe4c9ac683aeaff0b685823
  getPkgs :: Defs.PName -> Defs.Database -> GHC.Base.Maybe [Defs.Pkg]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: (\ (p :: Defs.PName) (ds :: Defs.Database) ->
                 case Data.OldList.sortBy
                        @ Defs.Pkg
                        SolverImpl.getPkgs1
                        (GHC.List.filter
                           @ Defs.Pkg
                           (\ (x :: Defs.Pkg) ->
                            case x of wild { Defs.Pkg ds4 ds5 ds6 ds7 ->
                            GHC.Base.eqString
                              p `cast` (Defs.N:PName[0])
                              ds4 `cast` (Defs.N:PName[0]) })
                           ds `cast` (Defs.N:Database[0])) of wild {
                   [] -> GHC.Base.Nothing @ [Defs.Pkg]
                   : ipv ipv1 -> GHC.Base.Just @ [Defs.Pkg] wild }) -}
982174b805d3ef1aef9b52763b737cb3
  getPkgs1 :: Defs.Pkg -> Defs.Pkg -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LSLL),1*U(A,1*U,A,A)><S(LSLL),1*U(A,1*U,A,A)>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Defs.Pkg) (y :: Defs.Pkg)[OneShot] ->
                 case y of wild { Defs.Pkg ds4 ds5 ds6 ds7 ->
                 case x of wild1 { Defs.Pkg ds1 ds2 ds3 ds10 ->
                 GHC.Classes.$fOrd[]_$ccompare
                   @ Defs.VNum
                   Defs.$fOrdVNum
                   ds5 `cast` (Defs.N:Version[0])
                   ds2 `cast` (Defs.N:Version[0]) } }) -}
31a7323b04602f804a38a850f3da7cc6
  getSols :: Defs.Database -> [Defs.Pkg] -> GHC.Base.Maybe [Defs.Sol]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: (\ (db :: Defs.Database) (pkgs :: [Defs.Pkg]) ->
                 let {
                   lvl15 :: ([Defs.Sol], Defs.Database)
                   = (GHC.Types.[] @ Defs.Sol, db)
                 } in
                 letrec {
                   go1 :: [Defs.Pkg] -> [Defs.Sol] {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [Defs.Pkg]) ->
                     case ds of wild {
                       [] -> GHC.Types.[] @ Defs.Sol
                       : y ys
                       -> case y of wild1 { Defs.Pkg ds4 ds5 ds6 ds7 ->
                          case (SolverImpl.solve
                                  ds7
                                  (GHC.Types.:
                                     @ (Defs.PName, Defs.Version)
                                     (ds4, ds5)
                                     (GHC.Types.[] @ (Defs.PName, Defs.Version))))
                                 `cast`
                               (SolverImpl.N:Solver[0] <()>_R)
                                 lvl15 of wild2 { (,) ds1 y1 ->
                          GHC.Base.++ @ [(Defs.PName, Defs.Version)] y1 (go1 ys) } } }
                 } in
                 case go1 pkgs of wild {
                   [] -> GHC.Base.Nothing @ [Defs.Sol]
                   : ipv ipv1 -> GHC.Base.Just @ [Defs.Sol] wild }) -}
6ad841de8834722bc46dbf4c9854811f
  groupByName :: [Defs.Pkg] -> [[Defs.Pkg]]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
162e655f08d13f242a32040753280a18
  inSol :: Defs.Pkg -> Defs.Sol -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U(U,A,A,A)><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                SolverImpl.inSol1
                  `cast`
                (<Defs.Pkg>_R
                 ->_R <[(Defs.PName, Defs.Version)]>_R
                 ->_R Data.Semigroup.Internal.N:Any[0]) -}
bf857a0c2bda527d1c29664296d74221
  inSol1 ::
    Defs.Pkg
    -> [(Defs.PName, Defs.Version)] -> Data.Semigroup.Internal.Any
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U(U,A,A,A)><S,1*U>,
     Unfolding: (\ (pkg :: Defs.Pkg)
                   (eta :: [(Defs.PName, Defs.Version)]) ->
                 letrec {
                   go1 :: [(Defs.PName, Defs.Version)] -> Data.Semigroup.Internal.Any
                     <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [(Defs.PName, Defs.Version)]) ->
                     case ds of wild {
                       []
                       -> GHC.Types.False `cast` (Sym (Data.Semigroup.Internal.N:Any[0]))
                       : y ys
                       -> case y of wild1 { (,) p ds1 ->
                          case pkg of wild2 { Defs.Pkg ds4 ds5 ds6 ds7 ->
                          case GHC.Base.eqString
                                 p `cast` (Defs.N:PName[0])
                                 ds4 `cast` (Defs.N:PName[0]) of wild3 {
                            GHC.Types.False -> go1 ys
                            GHC.Types.True
                            -> GHC.Types.True
                                 `cast`
                               (Sym (Data.Semigroup.Internal.N:Any[0])) } } } }
                 } in
                 go1 eta) -}
583827623afc00e852db93b7de6d8652
  install :: Defs.Database -> Defs.PName -> GHC.Base.Maybe Defs.Sol
  {- Arity: 2, Strictness: <S,U><L,U>,
     Unfolding: (\ (db :: Defs.Database) (p :: Defs.PName) ->
                 case SolverImpl.getPkgs p db of wild {
                   GHC.Base.Nothing -> GHC.Base.Nothing @ Defs.Sol
                   GHC.Base.Just x
                   -> case SolverImpl.getSols db x of wild1 {
                        GHC.Base.Nothing -> GHC.Base.Nothing @ Defs.Sol
                        GHC.Base.Just x1
                        -> GHC.Base.Just @ Defs.Sol (GHC.List.head @ Defs.Sol x1) } }) -}
24b6b9ad68302772a33c6f28cc2dd00f
  isRequired :: Defs.Pkg -> Defs.Constrs -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U(U,A,A,A)><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                SolverImpl.isRequired1
                  `cast`
                (<Defs.Pkg>_R
                 ->_R <[(Defs.PName,
                         (GHC.Types.Bool, Defs.Version, Defs.Version))]>_R
                 ->_R Data.Semigroup.Internal.N:Any[0]) -}
d33967dd873b702028c0c31a39fae0f4
  isRequired1 ::
    Defs.Pkg
    -> [(Defs.PName, (GHC.Types.Bool, Defs.Version, Defs.Version))]
    -> Data.Semigroup.Internal.Any
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U(U,A,A,A)><S,1*U>,
     Unfolding: (\ (pkg :: Defs.Pkg)
                   (eta :: [(Defs.PName,
                             (GHC.Types.Bool, Defs.Version, Defs.Version))]) ->
                 letrec {
                   go1 :: [(Defs.PName, (GHC.Types.Bool, Defs.Version, Defs.Version))]
                          -> Data.Semigroup.Internal.Any
                     <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [(Defs.PName,
                                (GHC.Types.Bool, Defs.Version, Defs.Version))]) ->
                     case ds of wild {
                       []
                       -> GHC.Types.False `cast` (Sym (Data.Semigroup.Internal.N:Any[0]))
                       : y ys
                       -> case y of wild1 { (,) p ds1 ->
                          case ds1 of wild2 { (,,) b ds2 ds3 ->
                          case b of wild3 {
                            GHC.Types.False -> go1 ys
                            GHC.Types.True
                            -> case pkg of wild4 { Defs.Pkg ds4 ds5 ds6 ds7 ->
                               case GHC.Base.eqString
                                      ds4 `cast` (Defs.N:PName[0])
                                      p `cast` (Defs.N:PName[0]) of wild5 {
                                 GHC.Types.False -> go1 ys
                                 GHC.Types.True
                                 -> GHC.Types.True
                                      `cast`
                                    (Sym (Data.Semigroup.Internal.N:Any[0])) } } } } } }
                 } in
                 go1 eta) -}
6773ef2baab4c45b930d2b51eb0ced37
  normalize ::
    Defs.Database -> Data.Either.Either GHC.Base.String Defs.Database
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Defs.Database) ->
                 case SolverImpl.normalize' ds `cast` (Defs.N:Database[0]) of wild {
                   Data.Either.Left x
                   -> Data.Either.Left @ [GHC.Types.Char] @ Defs.Database x
                   Data.Either.Right y
                   -> Data.Either.Right
                        @ [GHC.Types.Char]
                        @ Defs.Database
                        y `cast` (Sym (Defs.N:Database[0])) }) -}
f8cee73e2dc05e389ed9238c0f99be13
  normalize' ::
    [Defs.Pkg] -> Data.Either.Either GHC.Base.String [Defs.Pkg]
  {- Arity: 1, Strictness: <S,1*U> -}
053bfed86fed13ebbe7a1c1e08bdb661
  normalize'' ::
    Defs.Pkg
    -> [Defs.Pkg]
    -> ([Defs.Pkg], [Defs.Pkg])
    -> Data.Either.Either [GHC.Types.Char] ([Defs.Pkg], [Defs.Pkg])
  {- Arity: 3, Strictness: <L,1*U(U,U,U,U)><S,1*U><L,U(U,U)> -}
2915168f6e34cdc88147c1d7949e5007
  put :: Defs.Sol -> SolverImpl.Solver ()
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U(U,A)>m,
     Unfolding: InlineRule (0, True, True)
                SolverImpl.put1
                  `cast`
                (<Defs.Sol>_R ->_R Sym (SolverImpl.N:Solver[0] <()>_R)) -}
fc93d27b836cef7c0e9df50770cc7e4c
  put1 :: Defs.Sol -> ([Defs.Sol], Defs.Database) -> ((), [Defs.Sol])
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U(U,A)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (s' :: Defs.Sol) (ds :: ([Defs.Sol], Defs.Database)) ->
                 case ds of wild { (,) s ds1 ->
                 (GHC.Tuple.(), GHC.Types.: @ Defs.Sol s' s) }) -}
5cfefe465feabd59e33d095dbd64677f
  quality :: Defs.Sol -> Defs.Sol -> GHC.Types.Ordering
  {- Arity: 2, Strictness: <S,U><S,U>,
     Unfolding: (\ (sol1 :: Defs.Sol) (sol2 :: Defs.Sol) ->
                 case GHC.List.$wlenAcc
                        @ (Defs.PName, Defs.Version)
                        sol1
                        0# of ww2 { DEFAULT ->
                 case GHC.List.$wlenAcc
                        @ (Defs.PName, Defs.Version)
                        sol2
                        0# of ww1 { DEFAULT ->
                 case GHC.Prim.<# ww2 ww1 of lwild {
                   DEFAULT
                   -> case GHC.Prim.># ww2 ww1 of lwild1 {
                        DEFAULT
                        -> SolverImpl.$wgo2
                             (Data.OldList.sortBy
                                @ (Defs.PName, Defs.Version)
                                SolverImpl.quality2
                                sol1)
                             (Data.OldList.sortBy
                                @ (Defs.PName, Defs.Version)
                                SolverImpl.quality2
                                sol2)
                             SolverImpl.quality1
                             SolverImpl.quality1
                        1# -> GHC.Types.LT }
                   1# -> GHC.Types.GT } } }) -}
b96fa7d7130a94ea788b3e3887d297da
  quality1 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (0) -}
e4867e0e9d7516f5331d40649bd65f1b
  quality2 ::
    (Defs.PName, Defs.Version)
    -> (Defs.PName, Defs.Version) -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U,1*U)><S(SL),1*U(1*U,1*U)>, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: (Defs.PName, Defs.Version))
                   (w1 :: (Defs.PName, Defs.Version)) ->
                 case w of ww { (,) ww1 ww2 ->
                 case w1 of ww3 { (,) ww4 ww5 ->
                 SolverImpl.$wlvl1 ww1 ww2 ww4 ww5 } }) -}
02ffede47e67f7d8fd30284ba86e7a22
  runSolver ::
    SolverImpl.Solver a -> SolverImpl.Context -> (a, [Defs.Sol])
  RecSel Left SolverImpl.Solver
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True)
                SolverImpl.runSolver1
                  `cast`
                (forall (a :: <*>_N).
                 <SolverImpl.Solver a>_R ->_R SolverImpl.N:Solver[0] <a>_R) -}
02ffede47e67f7d8fd30284ba86e7a22
  runSolver1 :: SolverImpl.Solver a -> SolverImpl.Solver a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True)
                (\ @ a (ds :: SolverImpl.Solver a) -> ds) -}
5afb648d79fa4b2ce839cc40943c022c
  solve :: Defs.Constrs -> Defs.Sol -> SolverImpl.Solver ()
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><L,U> -}
135feddc93925a733c54952ad176e33d
  takeIfSat ::
    [Defs.Pkg]
    -> (Defs.Constrs, Defs.Sol)
    -> GHC.Base.Maybe (Defs.Constrs, Defs.Sol)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S(SL),1*U(U,1*U)>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: [Defs.Pkg]) (w1 :: (Defs.Constrs, Defs.Sol)) ->
                 case w1 of ww { (,) ww1 ww2 ->
                 SolverImpl.$wtakeIfSat w ww1 ww2 }) -}
7f0afda36964592c4aa7fb684c82813a
  takeIfSat1 :: Defs.Pkg -> (Defs.PName, Defs.Version)
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(1*U,1*U,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (eta :: Defs.Pkg) -> (Defs.name eta, Defs.ver eta)) -}
b3c43fb7e5c82ac40d13cb7569456be9
  toSol :: [Defs.Pkg] -> Defs.Sol
  {- Arity: 1, HasNoCafRefs,
     Unfolding: (GHC.Base.map
                   @ Defs.Pkg
                   @ (Defs.PName, Defs.Version)
                   SolverImpl.takeIfSat1) -}
instance [safe] GHC.Base.Applicative [SolverImpl.Solver]
  = SolverImpl.$fApplicativeSolver
instance [safe] GHC.Base.Functor [SolverImpl.Solver]
  = SolverImpl.$fFunctorSolver
instance [safe] GHC.Base.Monad [SolverImpl.Solver]
  = SolverImpl.$fMonadSolver
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

