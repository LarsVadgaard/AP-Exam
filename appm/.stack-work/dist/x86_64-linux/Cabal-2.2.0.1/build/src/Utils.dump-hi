
==================== FINAL INTERFACE ====================
2018-11-05 01:23:51.109800005 UTC

interface appm-0.0.0-bBoXP3Z3yF8cAWvQVfHOK:Utils 8043
  interface hash: 093972444b5c2377948307fb127b48ec
  ABI hash: 56e11831633c003055841737133cc50e
  export-list hash: 530081d4b74e471a0e493728d7b6b796
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 1f596daf84c7527444ae092b33472386
  opt_hash: 14e536840aca4e889cad654e6f9b79c1
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  sig of: Nothing
  used TH splices: False
  where
exports:
  Utils.intersection
  Utils.merge
  Utils.merge'
  Utils.satisfies
  Utils.satisfies'
module dependencies: Defs
package dependencies: base-4.11.1.0* ghc-prim-0.5.2.0
                      integer-gmp-1.0.2.0
orphans: base-4.11.1.0:GHC.Float base-4.11.1.0:GHC.Base
family instance modules: base-4.11.1.0:Control.Applicative
                         base-4.11.1.0:Data.Functor.Const
                         base-4.11.1.0:Data.Functor.Identity base-4.11.1.0:Data.Monoid
                         base-4.11.1.0:Data.Semigroup.Internal base-4.11.1.0:GHC.Generics
                         base-4.11.1.0:GHC.IO.Exception
import  -/  Defs 33704ed0d96c186bd2b1ffcf2d3c5e21
  exports: d483d9f9fac845ad0d3d1b6b82a00958
  Constrs 8c166b6e32f01bcd8bb0027ca3b54fbe
  PConstr eea4ebb637b297d1a426835d321dacfb
  PName 5f19c9b9fbea2b2b9245083ff941c0d5
  Sol 937cea62bc665f23bf865f9bce4039de
import  -/  base-4.11.1.0:Control.Monad c5f960c67d822497578bffbd3e4c01cf
import  -/  base-4.11.1.0:Data.Foldable 8ed35c38958063956af33c935ea03444
import  -/  base-4.11.1.0:Data.Functor f522c3501272159820fd6f242510732f
import  -/  base-4.11.1.0:Data.List 83dc843e47bfc0c5af51e19c6f3476d5
import  -/  base-4.11.1.0:GHC.Base 604111500e81281298777e721c75643b
import  -/  base-4.11.1.0:Prelude 0750c25585e2b797cd78291d423d39dd
import  -/  ghc-prim-0.5.2.0:GHC.Classes 122abfcd7450c6c11602933c9ca5f80d
eef3f0a7953f2b51e326aa10b095d049
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Utils.$trModule3 Utils.$trModule1) -}
ae7f7252d9b290ca533bfe0382625771
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Utils.$trModule2) -}
6b13b6f9d0f9d99381a12c4e76c73aa1
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Utils"#) -}
fc34c6002777919df592de85388fbcbc
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Utils.$trModule4) -}
160bcb365d191bd50bee6df889b55efd
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("appm-0.0.0-bBoXP3Z3yF8cAWvQVfHOK"#) -}
aa07d5964740b3ca2b5b192b60814aab
  $wintersection ::
    GHC.Classes.Ord c =>
    GHC.Types.Bool
    -> c
    -> c
    -> GHC.Types.Bool
    -> c
    -> c
    -> GHC.Base.Maybe (GHC.Types.Bool, c, c)
  {- Arity: 7, HasNoCafRefs,
     Strictness: <S(LLLC(C(S))LLLL),U(A,A,A,1*C1(C1(U)),A,A,1*C1(C1(U)),1*C1(C1(U)))><L,1*U><L,U><L,U><L,1*U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ c
                   (w :: GHC.Classes.Ord c)
                   (ww :: GHC.Types.Bool)
                   (ww1 :: c)
                   (ww2 :: c)
                   (ww3 :: GHC.Types.Bool)
                   (ww4 :: c)
                   (ww5 :: c) ->
                 let {
                   ds :: c = GHC.Classes.max @ c w ww1 ww4
                 } in
                 let {
                   ds1 :: c = GHC.Classes.min @ c w ww2 ww5
                 } in
                 case GHC.Classes.<= @ c w ds1 ds of wild {
                   GHC.Types.False
                   -> GHC.Base.Just
                        @ (GHC.Types.Bool, c, c)
                        (GHC.Classes.|| ww ww3, ds, ds1)
                   GHC.Types.True -> GHC.Base.Nothing @ (GHC.Types.Bool, c, c) }) -}
d746fa8d91adc2ecd0cf1308d6532b61
  $wsatisfies' ::
    Defs.Sol
    -> Defs.PName
    -> GHC.Types.Bool
    -> Defs.Version
    -> Defs.Version
    -> GHC.Types.Bool
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S,1*U><L,U><S,1*U><L,U><L,U>, Inline: [0],
     Unfolding: (\ (w :: Defs.Sol)
                   (ww :: Defs.PName)
                   (ww1 :: GHC.Types.Bool)
                   (ww2 :: Defs.Version)
                   (ww3 :: Defs.Version) ->
                 case ww1 of wild {
                   GHC.Types.False
                   -> letrec {
                        go :: [(Defs.PName, Defs.Version)] -> GHC.Types.Bool
                          <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                        = \ (ds :: [(Defs.PName, Defs.Version)]) ->
                          case ds of wild1 {
                            [] -> GHC.Types.True
                            : y ys
                            -> case y of wild2 { (,) p' v ->
                               case GHC.Base.eqString
                                      p' `cast` (Defs.N:PName[0])
                                      ww `cast` (Defs.N:PName[0]) of wild3 {
                                 GHC.Types.False -> go ys
                                 GHC.Types.True
                                 -> case GHC.Classes.$fOrd[]_$ccompare
                                           @ Defs.VNum
                                           Defs.$fOrdVNum
                                           v `cast` (Defs.N:Version[0])
                                           ww2 `cast` (Defs.N:Version[0]) of wild4 {
                                      DEFAULT
                                      -> case GHC.Classes.$fOrd[]_$ccompare
                                                @ Defs.VNum
                                                Defs.$fOrdVNum
                                                v `cast` (Defs.N:Version[0])
                                                ww3 `cast` (Defs.N:Version[0]) of wild5 {
                                           DEFAULT -> GHC.Types.False GHC.Types.LT -> go ys }
                                      GHC.Types.LT -> GHC.Types.False } } } }
                      } in
                      go w
                   GHC.Types.True
                   -> letrec {
                        go :: [(Defs.PName, Defs.Version)] -> GHC.Types.Bool
                          <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                        = \ (ds :: [(Defs.PName, Defs.Version)]) ->
                          case ds of wild1 {
                            [] -> GHC.Types.False
                            : y ys
                            -> case y of wild2 { (,) p' v ->
                               case GHC.Base.eqString
                                      p' `cast` (Defs.N:PName[0])
                                      ww `cast` (Defs.N:PName[0]) of wild3 {
                                 GHC.Types.False -> go ys
                                 GHC.Types.True
                                 -> case GHC.Classes.$fOrd[]_$ccompare
                                           @ Defs.VNum
                                           Defs.$fOrdVNum
                                           v `cast` (Defs.N:Version[0])
                                           ww2 `cast` (Defs.N:Version[0]) of wild4 {
                                      DEFAULT
                                      -> case GHC.Classes.$fOrd[]_$ccompare
                                                @ Defs.VNum
                                                Defs.$fOrdVNum
                                                v `cast` (Defs.N:Version[0])
                                                ww3 `cast` (Defs.N:Version[0]) of wild5 {
                                           DEFAULT -> go ys GHC.Types.LT -> GHC.Types.True }
                                      GHC.Types.LT -> go ys } } } }
                      } in
                      go w }) -}
9f892debcd101b00983ea46f511d7a64
  intersection ::
    GHC.Classes.Ord c =>
    (GHC.Types.Bool, c, c)
    -> (GHC.Types.Bool, c, c) -> GHC.Base.Maybe (GHC.Types.Bool, c, c)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LLLC(C(S))LLLL),U(A,A,A,C(C1(U)),A,A,C(C1(U)),C(C1(U)))><S,1*U(1*U,U,U)><S,1*U(1*U,U,U)>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ c
                   (w :: GHC.Classes.Ord c)
                   (w1 :: (GHC.Types.Bool, c, c))
                   (w2 :: (GHC.Types.Bool, c, c)) ->
                 case w1 of ww { (,,) ww1 ww2 ww3 ->
                 case w2 of ww4 { (,,) ww5 ww6 ww7 ->
                 Utils.$wintersection @ c w ww1 ww2 ww3 ww5 ww6 ww7 } }) -}
d812c272c54c91bb461d01992a41eec5
  merge ::
    Defs.Constrs -> Defs.Constrs -> GHC.Base.Maybe Defs.Constrs
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>,
     Unfolding: (\ (c1 :: Defs.Constrs) (c2 :: Defs.Constrs) ->
                 let {
                   exit :: [(Defs.PName,
                             (GHC.Types.Bool, Defs.Version, Defs.Version))]
                           -> GHC.Base.Maybe
                                [(Defs.PName, (GHC.Types.Bool, Defs.Version, Defs.Version))]
                     <join 1> {- Arity: 1, Strictness: <L,U> -}
                   = \ (eta :: [(Defs.PName,
                                 (GHC.Types.Bool, Defs.Version, Defs.Version))])[OneShot] ->
                     Utils.merge_go c2 eta
                 } in
                 letrec {
                   go :: [(Defs.PName, Defs.PConstr)]
                         -> [(Defs.PName, (GHC.Types.Bool, Defs.Version, Defs.Version))]
                         -> GHC.Base.Maybe
                              [(Defs.PName, (GHC.Types.Bool, Defs.Version, Defs.Version))]
                     <join 2> {- Arity: 2, Strictness: <S,1*U><L,U> -}
                   = \ (ds :: [(Defs.PName, Defs.PConstr)])
                       (eta :: [(Defs.PName,
                                 (GHC.Types.Bool, Defs.Version, Defs.Version))]) ->
                     case ds of wild {
                       [] -> exit eta
                       : y ys
                       -> case Utils.merge_merge' eta y of wild1 {
                            GHC.Base.Nothing
                            -> GHC.Base.Nothing
                                 @ [(Defs.PName, (GHC.Types.Bool, Defs.Version, Defs.Version))]
                            GHC.Base.Just x -> go ys x } }
                 } in
                 go
                   c1
                   (GHC.Types.[]
                      @ (Defs.PName, (GHC.Types.Bool, Defs.Version, Defs.Version)))) -}
67e11a59717b386f53084ea06c069a5c
  merge' ::
    (GHC.Classes.Ord c, GHC.Classes.Eq a) =>
    [(a, (GHC.Types.Bool, c, c))]
    -> (a, (GHC.Types.Bool, c, c))
    -> GHC.Base.Maybe [(a, (GHC.Types.Bool, c, c))]
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U(A,A,A,C(C1(U)),A,A,C(C1(U)),C(C1(U)))><L,U(C(C1(U)),A)><S,1*U><L,U(U,U(U,U,U))>,
     Unfolding: (\ @ c
                   @ a
                   ($dOrd :: GHC.Classes.Ord c)
                   ($dEq :: GHC.Classes.Eq a)
                   (eta :: [(a, (GHC.Types.Bool, c, c))])
                   (eta1 :: (a, (GHC.Types.Bool, c, c))) ->
                 letrec {
                   merge'1 :: [(a, (GHC.Types.Bool, c, c))]
                              -> (a, (GHC.Types.Bool, c, c))
                              -> GHC.Base.Maybe [(a, (GHC.Types.Bool, c, c))]
                     {- Arity: 2, Strictness: <S,1*U><L,U(U,U(U,U,U))> -}
                   = \ (ds :: [(a, (GHC.Types.Bool, c, c))])
                       (ds1 :: (a, (GHC.Types.Bool, c, c))) ->
                     case ds of wild {
                       []
                       -> GHC.Base.Just
                            @ [(a, (GHC.Types.Bool, c, c))]
                            (GHC.Types.:
                               @ (a, (GHC.Types.Bool, c, c))
                               ds1
                               (GHC.Types.[] @ (a, (GHC.Types.Bool, c, c))))
                       : ds2 lst
                       -> case ds2 of wild1 { (,) p c1 ->
                          case ds1 of wild2 { (,) p' c' ->
                          case GHC.Classes.== @ a $dEq p p' of wild3 {
                            GHC.Types.False
                            -> case merge'1 lst wild2 of wild4 {
                                 GHC.Base.Nothing
                                 -> GHC.Base.Nothing @ [(a, (GHC.Types.Bool, c, c))]
                                 GHC.Base.Just a1
                                 -> GHC.Base.Just
                                      @ [(a, (GHC.Types.Bool, c, c))]
                                      (GHC.Types.: @ (a, (GHC.Types.Bool, c, c)) wild1 a1) }
                            GHC.Types.True
                            -> case c1 of ww { (,,) ww1 ww2 ww3 ->
                               case c' of ww4 { (,,) ww5 ww6 ww7 ->
                               case Utils.$wintersection
                                      @ c
                                      $dOrd
                                      ww1
                                      ww2
                                      ww3
                                      ww5
                                      ww6
                                      ww7 of wild4 {
                                 GHC.Base.Nothing
                                 -> GHC.Base.Nothing @ [(a, (GHC.Types.Bool, c, c))]
                                 GHC.Base.Just x
                                 -> GHC.Base.Just
                                      @ [(a, (GHC.Types.Bool, c, c))]
                                      (GHC.Types.:
                                         @ (a, (GHC.Types.Bool, c, c))
                                         (p, x)
                                         lst) } } } } } } }
                 } in
                 merge'1 eta eta1) -}
4835617f6a869d42cc1b7b2cdd8a8e00
  merge_go ::
    [(Defs.PName, (GHC.Types.Bool, Defs.Version, Defs.Version))]
    -> [(Defs.PName, (GHC.Types.Bool, Defs.Version, Defs.Version))]
    -> GHC.Base.Maybe
         [(Defs.PName, (GHC.Types.Bool, Defs.Version, Defs.Version))]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U> -}
1781886651709d71beb41aae1109fcb7
  merge_merge' ::
    [(Defs.PName, (GHC.Types.Bool, Defs.Version, Defs.Version))]
    -> (Defs.PName, (GHC.Types.Bool, Defs.Version, Defs.Version))
    -> GHC.Base.Maybe
         [(Defs.PName, (GHC.Types.Bool, Defs.Version, Defs.Version))]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U(U,U(U,U,U))> -}
cfdac64241c4143c94a0b289e5bb6de9
  satisfies :: Defs.Sol -> Defs.Constrs -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Utils.satisfies1
                  `cast`
                (<Defs.Sol>_R
                 ->_R <[(Defs.PName, Defs.PConstr)]>_R
                 ->_R Data.Semigroup.Internal.N:All[0]) -}
a9bd320fbc3adc3b418d3bb7e03736ff
  satisfies' ::
    Defs.Sol -> (Defs.PName, Defs.PConstr) -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U><S(LS(SLL)),1*U(U,1*U(1*U,U,U))>, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Defs.Sol) (w1 :: (Defs.PName, Defs.PConstr)) ->
                 case w1 of ww { (,) ww1 ww2 ->
                 case ww2 of ww3 { (,,) ww4 ww5 ww6 ->
                 Utils.$wsatisfies' w ww1 ww4 ww5 ww6 } }) -}
32033c617c7eebaf7514aa37f774b8fd
  satisfies1 ::
    Defs.Sol
    -> [(Defs.PName, Defs.PConstr)] -> Data.Semigroup.Internal.All
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (sol :: Defs.Sol) (eta :: [(Defs.PName, Defs.PConstr)]) ->
                 letrec {
                   go :: [(Defs.PName, Defs.PConstr)] -> Data.Semigroup.Internal.All
                     <join 1> {- Arity: 1 -}
                   = \ (ds :: [(Defs.PName, Defs.PConstr)]) ->
                     case ds of wild {
                       []
                       -> GHC.Types.True `cast` (Sym (Data.Semigroup.Internal.N:All[0]))
                       : y ys
                       -> case Utils.satisfies' sol y of wild1 {
                            GHC.Types.False
                            -> GHC.Types.False `cast` (Sym (Data.Semigroup.Internal.N:All[0]))
                            GHC.Types.True -> go ys } }
                 } in
                 go eta) -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

