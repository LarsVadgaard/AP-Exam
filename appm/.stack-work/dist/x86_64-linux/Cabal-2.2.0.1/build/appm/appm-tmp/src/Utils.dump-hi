
==================== FINAL INTERFACE ====================
2018-11-05 01:23:53.983322653 UTC

interface main:Utils 8043
  interface hash: 1622fe001e18615fb5a44d8e451c371d
  ABI hash: 4f98c61aa38838f38e3d1e041c1d0979
  export-list hash: 1b834eb832ec9a3ae541398e0df3efef
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 8159db7c32bdb9b5583c3379f950f8b0
  opt_hash: 14e536840aca4e889cad654e6f9b79c1
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  sig of: Nothing
  used TH splices: False
  where
exports:
  Utils.intersection
  Utils.merge
  Utils.merge'
  Utils.satisfies
  Utils.satisfies'
module dependencies: Defs
package dependencies: base-4.11.1.0* ghc-prim-0.5.2.0
                      integer-gmp-1.0.2.0
orphans: base-4.11.1.0:GHC.Float base-4.11.1.0:GHC.Base
family instance modules: base-4.11.1.0:Control.Applicative
                         base-4.11.1.0:Data.Functor.Const
                         base-4.11.1.0:Data.Functor.Identity base-4.11.1.0:Data.Monoid
                         base-4.11.1.0:Data.Semigroup.Internal base-4.11.1.0:GHC.Generics
                         base-4.11.1.0:GHC.IO.Exception
import  -/  base-4.11.1.0:Control.Monad c5f960c67d822497578bffbd3e4c01cf
import  -/  base-4.11.1.0:Data.Foldable 8ed35c38958063956af33c935ea03444
import  -/  base-4.11.1.0:Data.Functor f522c3501272159820fd6f242510732f
import  -/  base-4.11.1.0:Data.List 83dc843e47bfc0c5af51e19c6f3476d5
import  -/  base-4.11.1.0:GHC.Base 604111500e81281298777e721c75643b
import  -/  base-4.11.1.0:Prelude 0750c25585e2b797cd78291d423d39dd
import  -/  ghc-prim-0.5.2.0:GHC.Classes 122abfcd7450c6c11602933c9ca5f80d
import  -/  Defs d68c6b51a0680ceeccb798bbdf84422d
  exports: 5ff9e865f120cee4a14d24bffcee71a0
  Constrs 9a7c3453c9d2e31f7e4903b75f608e72
  PConstr 78cf45f9e0d6beb5a2f0eabf20ae0f3f
  PName f57ad031236d47377cee1c770af63619
  Sol ecbba19d4c7e407535cb2f8a0395ec83
6e4cfbbe250611482ac08c6d558f4dce
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Utils.$trModule3 Utils.$trModule1) -}
6ea2ae0a946ba28d3e9a92ae079dc36e
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Utils.$trModule2) -}
c81636fcbf58b412e558c29d269dd105
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Utils"#) -}
48e9693c199df8b405168bfddb9c283b
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Utils.$trModule4) -}
be56da26131302c822ff452d3bc5ec6f
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("main"#) -}
6908320b76c9bbca3d6a405b169e9457
  $wintersection ::
    GHC.Classes.Ord c =>
    GHC.Types.Bool
    -> c
    -> c
    -> GHC.Types.Bool
    -> c
    -> c
    -> GHC.Base.Maybe (GHC.Types.Bool, c, c)
  {- Arity: 7, HasNoCafRefs,
     Strictness: <S(LLLC(C(S))LLLL),U(A,A,A,1*C1(C1(U)),A,A,1*C1(C1(U)),1*C1(C1(U)))><L,1*U><L,U><L,U><L,1*U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ c
                   (w :: GHC.Classes.Ord c)
                   (ww :: GHC.Types.Bool)
                   (ww1 :: c)
                   (ww2 :: c)
                   (ww3 :: GHC.Types.Bool)
                   (ww4 :: c)
                   (ww5 :: c) ->
                 let {
                   ds :: c = GHC.Classes.max @ c w ww1 ww4
                 } in
                 let {
                   ds1 :: c = GHC.Classes.min @ c w ww2 ww5
                 } in
                 case GHC.Classes.<= @ c w ds1 ds of wild {
                   GHC.Types.False
                   -> GHC.Base.Just
                        @ (GHC.Types.Bool, c, c)
                        (GHC.Classes.|| ww ww3, ds, ds1)
                   GHC.Types.True -> GHC.Base.Nothing @ (GHC.Types.Bool, c, c) }) -}
c1c612f555b15eea308e035ccadaf59c
  $wsatisfies' ::
    Defs.Sol
    -> Defs.PName
    -> GHC.Types.Bool
    -> Defs.Version
    -> Defs.Version
    -> GHC.Types.Bool
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S,1*U><L,U><S,1*U><L,U><L,U>, Inline: [0],
     Unfolding: (\ (w :: Defs.Sol)
                   (ww :: Defs.PName)
                   (ww1 :: GHC.Types.Bool)
                   (ww2 :: Defs.Version)
                   (ww3 :: Defs.Version) ->
                 case ww1 of wild {
                   GHC.Types.False
                   -> letrec {
                        go :: [(Defs.PName, Defs.Version)] -> GHC.Types.Bool
                          <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                        = \ (ds :: [(Defs.PName, Defs.Version)]) ->
                          case ds of wild1 {
                            [] -> GHC.Types.True
                            : y ys
                            -> case y of wild2 { (,) p' v ->
                               case GHC.Base.eqString
                                      p' `cast` (Defs.N:PName[0])
                                      ww `cast` (Defs.N:PName[0]) of wild3 {
                                 GHC.Types.False -> go ys
                                 GHC.Types.True
                                 -> case GHC.Classes.$fOrd[]_$ccompare
                                           @ Defs.VNum
                                           Defs.$fOrdVNum
                                           v `cast` (Defs.N:Version[0])
                                           ww2 `cast` (Defs.N:Version[0]) of wild4 {
                                      DEFAULT
                                      -> case GHC.Classes.$fOrd[]_$ccompare
                                                @ Defs.VNum
                                                Defs.$fOrdVNum
                                                v `cast` (Defs.N:Version[0])
                                                ww3 `cast` (Defs.N:Version[0]) of wild5 {
                                           DEFAULT -> GHC.Types.False GHC.Types.LT -> go ys }
                                      GHC.Types.LT -> GHC.Types.False } } } }
                      } in
                      go w
                   GHC.Types.True
                   -> letrec {
                        go :: [(Defs.PName, Defs.Version)] -> GHC.Types.Bool
                          <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                        = \ (ds :: [(Defs.PName, Defs.Version)]) ->
                          case ds of wild1 {
                            [] -> GHC.Types.False
                            : y ys
                            -> case y of wild2 { (,) p' v ->
                               case GHC.Base.eqString
                                      p' `cast` (Defs.N:PName[0])
                                      ww `cast` (Defs.N:PName[0]) of wild3 {
                                 GHC.Types.False -> go ys
                                 GHC.Types.True
                                 -> case GHC.Classes.$fOrd[]_$ccompare
                                           @ Defs.VNum
                                           Defs.$fOrdVNum
                                           v `cast` (Defs.N:Version[0])
                                           ww2 `cast` (Defs.N:Version[0]) of wild4 {
                                      DEFAULT
                                      -> case GHC.Classes.$fOrd[]_$ccompare
                                                @ Defs.VNum
                                                Defs.$fOrdVNum
                                                v `cast` (Defs.N:Version[0])
                                                ww3 `cast` (Defs.N:Version[0]) of wild5 {
                                           DEFAULT -> go ys GHC.Types.LT -> GHC.Types.True }
                                      GHC.Types.LT -> go ys } } } }
                      } in
                      go w }) -}
f5854a404623bf82a8bc5f0c6910617a
  intersection ::
    GHC.Classes.Ord c =>
    (GHC.Types.Bool, c, c)
    -> (GHC.Types.Bool, c, c) -> GHC.Base.Maybe (GHC.Types.Bool, c, c)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LLLC(C(S))LLLL),U(A,A,A,C(C1(U)),A,A,C(C1(U)),C(C1(U)))><S,1*U(1*U,U,U)><S,1*U(1*U,U,U)>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ c
                   (w :: GHC.Classes.Ord c)
                   (w1 :: (GHC.Types.Bool, c, c))
                   (w2 :: (GHC.Types.Bool, c, c)) ->
                 case w1 of ww { (,,) ww1 ww2 ww3 ->
                 case w2 of ww4 { (,,) ww5 ww6 ww7 ->
                 Utils.$wintersection @ c w ww1 ww2 ww3 ww5 ww6 ww7 } }) -}
c9d74a5272b0f05d443491f30ba98a54
  merge ::
    Defs.Constrs -> Defs.Constrs -> GHC.Base.Maybe Defs.Constrs
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>,
     Unfolding: (\ (c1 :: Defs.Constrs) (c2 :: Defs.Constrs) ->
                 let {
                   exit :: [(Defs.PName,
                             (GHC.Types.Bool, Defs.Version, Defs.Version))]
                           -> GHC.Base.Maybe
                                [(Defs.PName, (GHC.Types.Bool, Defs.Version, Defs.Version))]
                     <join 1> {- Arity: 1, Strictness: <L,U> -}
                   = \ (eta :: [(Defs.PName,
                                 (GHC.Types.Bool, Defs.Version, Defs.Version))])[OneShot] ->
                     Utils.merge_go c2 eta
                 } in
                 letrec {
                   go :: [(Defs.PName, Defs.PConstr)]
                         -> [(Defs.PName, (GHC.Types.Bool, Defs.Version, Defs.Version))]
                         -> GHC.Base.Maybe
                              [(Defs.PName, (GHC.Types.Bool, Defs.Version, Defs.Version))]
                     <join 2> {- Arity: 2, Strictness: <S,1*U><L,U> -}
                   = \ (ds :: [(Defs.PName, Defs.PConstr)])
                       (eta :: [(Defs.PName,
                                 (GHC.Types.Bool, Defs.Version, Defs.Version))]) ->
                     case ds of wild {
                       [] -> exit eta
                       : y ys
                       -> case Utils.merge_merge' eta y of wild1 {
                            GHC.Base.Nothing
                            -> GHC.Base.Nothing
                                 @ [(Defs.PName, (GHC.Types.Bool, Defs.Version, Defs.Version))]
                            GHC.Base.Just x -> go ys x } }
                 } in
                 go
                   c1
                   (GHC.Types.[]
                      @ (Defs.PName, (GHC.Types.Bool, Defs.Version, Defs.Version)))) -}
f52143c1c831fcb6c333ef312072eedc
  merge' ::
    (GHC.Classes.Ord c, GHC.Classes.Eq a) =>
    [(a, (GHC.Types.Bool, c, c))]
    -> (a, (GHC.Types.Bool, c, c))
    -> GHC.Base.Maybe [(a, (GHC.Types.Bool, c, c))]
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U(A,A,A,C(C1(U)),A,A,C(C1(U)),C(C1(U)))><L,U(C(C1(U)),A)><S,1*U><L,U(U,U(U,U,U))>,
     Unfolding: (\ @ c
                   @ a
                   ($dOrd :: GHC.Classes.Ord c)
                   ($dEq :: GHC.Classes.Eq a)
                   (eta :: [(a, (GHC.Types.Bool, c, c))])
                   (eta1 :: (a, (GHC.Types.Bool, c, c))) ->
                 letrec {
                   merge'1 :: [(a, (GHC.Types.Bool, c, c))]
                              -> (a, (GHC.Types.Bool, c, c))
                              -> GHC.Base.Maybe [(a, (GHC.Types.Bool, c, c))]
                     {- Arity: 2, Strictness: <S,1*U><L,U(U,U(U,U,U))> -}
                   = \ (ds :: [(a, (GHC.Types.Bool, c, c))])
                       (ds1 :: (a, (GHC.Types.Bool, c, c))) ->
                     case ds of wild {
                       []
                       -> GHC.Base.Just
                            @ [(a, (GHC.Types.Bool, c, c))]
                            (GHC.Types.:
                               @ (a, (GHC.Types.Bool, c, c))
                               ds1
                               (GHC.Types.[] @ (a, (GHC.Types.Bool, c, c))))
                       : ds2 lst
                       -> case ds2 of wild1 { (,) p c1 ->
                          case ds1 of wild2 { (,) p' c' ->
                          case GHC.Classes.== @ a $dEq p p' of wild3 {
                            GHC.Types.False
                            -> case merge'1 lst wild2 of wild4 {
                                 GHC.Base.Nothing
                                 -> GHC.Base.Nothing @ [(a, (GHC.Types.Bool, c, c))]
                                 GHC.Base.Just a1
                                 -> GHC.Base.Just
                                      @ [(a, (GHC.Types.Bool, c, c))]
                                      (GHC.Types.: @ (a, (GHC.Types.Bool, c, c)) wild1 a1) }
                            GHC.Types.True
                            -> case c1 of ww { (,,) ww1 ww2 ww3 ->
                               case c' of ww4 { (,,) ww5 ww6 ww7 ->
                               case Utils.$wintersection
                                      @ c
                                      $dOrd
                                      ww1
                                      ww2
                                      ww3
                                      ww5
                                      ww6
                                      ww7 of wild4 {
                                 GHC.Base.Nothing
                                 -> GHC.Base.Nothing @ [(a, (GHC.Types.Bool, c, c))]
                                 GHC.Base.Just x
                                 -> GHC.Base.Just
                                      @ [(a, (GHC.Types.Bool, c, c))]
                                      (GHC.Types.:
                                         @ (a, (GHC.Types.Bool, c, c))
                                         (p, x)
                                         lst) } } } } } } }
                 } in
                 merge'1 eta eta1) -}
de1b5633ea712bdbd7779b5a4bfe0d67
  merge_go ::
    [(Defs.PName, (GHC.Types.Bool, Defs.Version, Defs.Version))]
    -> [(Defs.PName, (GHC.Types.Bool, Defs.Version, Defs.Version))]
    -> GHC.Base.Maybe
         [(Defs.PName, (GHC.Types.Bool, Defs.Version, Defs.Version))]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U> -}
2414cd2a35d76ddf9992a80240719aba
  merge_merge' ::
    [(Defs.PName, (GHC.Types.Bool, Defs.Version, Defs.Version))]
    -> (Defs.PName, (GHC.Types.Bool, Defs.Version, Defs.Version))
    -> GHC.Base.Maybe
         [(Defs.PName, (GHC.Types.Bool, Defs.Version, Defs.Version))]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U(U,U(U,U,U))> -}
48f6f54f253be34b353d7dd3ef38e09b
  satisfies :: Defs.Sol -> Defs.Constrs -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Utils.satisfies1
                  `cast`
                (<Defs.Sol>_R
                 ->_R <[(Defs.PName, Defs.PConstr)]>_R
                 ->_R Data.Semigroup.Internal.N:All[0]) -}
54c00c8974c57510fc5f7ddc18763b9d
  satisfies' ::
    Defs.Sol -> (Defs.PName, Defs.PConstr) -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U><S(LS(SLL)),1*U(U,1*U(1*U,U,U))>, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Defs.Sol) (w1 :: (Defs.PName, Defs.PConstr)) ->
                 case w1 of ww { (,) ww1 ww2 ->
                 case ww2 of ww3 { (,,) ww4 ww5 ww6 ->
                 Utils.$wsatisfies' w ww1 ww4 ww5 ww6 } }) -}
808bd010a59fab7b5447dc31063ebf26
  satisfies1 ::
    Defs.Sol
    -> [(Defs.PName, Defs.PConstr)] -> Data.Semigroup.Internal.All
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (sol :: Defs.Sol) (eta :: [(Defs.PName, Defs.PConstr)]) ->
                 letrec {
                   go :: [(Defs.PName, Defs.PConstr)] -> Data.Semigroup.Internal.All
                     <join 1> {- Arity: 1 -}
                   = \ (ds :: [(Defs.PName, Defs.PConstr)]) ->
                     case ds of wild {
                       []
                       -> GHC.Types.True `cast` (Sym (Data.Semigroup.Internal.N:All[0]))
                       : y ys
                       -> case Utils.satisfies' sol y of wild1 {
                            GHC.Types.False
                            -> GHC.Types.False `cast` (Sym (Data.Semigroup.Internal.N:All[0]))
                            GHC.Types.True -> go ys } }
                 } in
                 go eta) -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

