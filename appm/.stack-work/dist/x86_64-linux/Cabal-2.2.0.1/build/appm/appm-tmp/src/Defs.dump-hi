
==================== FINAL INTERFACE ====================
2018-11-05 01:23:53.74836762 UTC

interface main:Defs 8043
  interface hash: 8f8686e7f031faf31e10bbbca54e48a8
  ABI hash: d68c6b51a0680ceeccb798bbdf84422d
  export-list hash: 5ff9e865f120cee4a14d24bffcee71a0
  orphan hash: bdb58337c2f062d28985a8b87c3c2b3e
  flag hash: 8159db7c32bdb9b5583c3379f950f8b0
  opt_hash: 14e536840aca4e889cad654e6f9b79c1
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  sig of: Nothing
  used TH splices: False
  where
exports:
  Defs.maxV
  Defs.minV
  Defs.prettyConstr
  Defs.prettyConstrs
  Defs.prettyPName
  Defs.prettyPkg
  Defs.prettyPkgs
  Defs.prettyVNum
  Defs.prettyVer
  Defs.stdV
  Defs.Constrs
  Defs.Database{Defs.DB}
  Defs.ErrMsg
  Defs.PConstr
  Defs.PName{Defs.P}
  Defs.Pkg{Defs.Pkg deps desc name ver}
  Defs.Sol
  Defs.VNum{Defs.VN}
  Defs.Version{Defs.V}
module dependencies:
package dependencies: base-4.11.1.0* ghc-prim-0.5.2.0
                      integer-gmp-1.0.2.0
orphans: base-4.11.1.0:GHC.Float base-4.11.1.0:GHC.Base
family instance modules: base-4.11.1.0:Control.Applicative
                         base-4.11.1.0:Data.Functor.Const
                         base-4.11.1.0:Data.Functor.Identity base-4.11.1.0:Data.Monoid
                         base-4.11.1.0:Data.Semigroup.Internal base-4.11.1.0:GHC.Generics
                         base-4.11.1.0:GHC.IO.Exception
import  -/  base-4.11.1.0:Data.Foldable 8ed35c38958063956af33c935ea03444
import  -/  base-4.11.1.0:Data.List 83dc843e47bfc0c5af51e19c6f3476d5
import  -/  base-4.11.1.0:Data.OldList 1b35aa3c6805ff7c8887a35a866fe006
import  -/  base-4.11.1.0:GHC.Base 604111500e81281298777e721c75643b
import  -/  base-4.11.1.0:GHC.Read b9e6d20d40da8c8a12b566d22e1160e0
import  -/  base-4.11.1.0:GHC.Show 73be67392447c974f19c3befd83c46c0
import  -/  base-4.11.1.0:Prelude 0750c25585e2b797cd78291d423d39dd
import  -/  base-4.11.1.0:Text.ParserCombinators.ReadPrec d0ebf984ed486435a97481288b73febb
import  -/  base-4.11.1.0:Text.Read.Lex f8ad6f9ae74ae325ba69a4fa5c82aaca
import  -/  ghc-prim-0.5.2.0:GHC.Classes 122abfcd7450c6c11602933c9ca5f80d
import  -/  ghc-prim-0.5.2.0:GHC.Types d9b3023de7feae4a5308d643da5543f7
f1583a426d94974bff3b76eacb5d8923
  $fEqDatabase :: GHC.Classes.Eq Defs.Database
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Defs.Database
                  Defs.$fEqDatabase1
                    `cast`
                  (Sym (Defs.N:Database[0])
                   ->_R Sym (Defs.N:Database[0])
                   ->_R <GHC.Types.Bool>_R)
                  Defs.$fEqDatabase_$s$fEq[]_$c/=
                    `cast`
                  (Sym (Defs.N:Database[0])
                   ->_R Sym (Defs.N:Database[0])
                   ->_R <GHC.Types.Bool>_R) -}
b4df5afeffa65830e354718e90a644b7
  $fEqDatabase1 :: [Defs.Pkg] -> [Defs.Pkg] -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Unfolding: (GHC.Classes.$fEq[]_$c== @ Defs.Pkg Defs.$fEqPkg) -}
bf44c5365f283ea2e2ec3abc8df3d832
  $fEqDatabase_$s$fEq[]_$c/= ::
    [Defs.Pkg] -> [Defs.Pkg] -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: [Defs.Pkg]) (y :: [Defs.Pkg]) ->
                 case GHC.Classes.$fEq[]_$c== @ Defs.Pkg Defs.$fEqPkg x y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
f57ad031236d47377cee1c770af63619
  $fEqPName :: GHC.Classes.Eq Defs.PName
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Defs.PName
                  GHC.Base.eqString
                    `cast`
                  (Sym (Defs.N:PName[0])
                   ->_R Sym (Defs.N:PName[0])
                   ->_R <GHC.Types.Bool>_R)
                  GHC.Classes.$fEq[]_$s$c/=1
                    `cast`
                  (Sym (Defs.N:PName[0])
                   ->_R Sym (Defs.N:PName[0])
                   ->_R <GHC.Types.Bool>_R) -}
67c0e1532f060e36c08615a4e1246c25
  $fEqPkg :: GHC.Classes.Eq Defs.Pkg
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:. @ Defs.Pkg Defs.$fEqPkg_$c== Defs.$fEqPkg_$c/= -}
67c0e1532f060e36c08615a4e1246c25
  $fEqPkg_$c/= :: Defs.Pkg -> Defs.Pkg -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLLL),1*U(1*U,1*U,1*U,1*U)><S(SLLL),1*U(1*U,1*U,1*U,1*U)>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: Defs.Pkg) (y :: Defs.Pkg) ->
                 case Defs.$fEqPkg_$c== x y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
67c0e1532f060e36c08615a4e1246c25
  $fEqPkg_$c== :: Defs.Pkg -> Defs.Pkg -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLLL),1*U(1*U,1*U,1*U,1*U)><S(SLLL),1*U(1*U,1*U,1*U,1*U)>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Defs.Pkg) (w1 :: Defs.Pkg) ->
                 case w of ww { Defs.Pkg ww1 ww2 ww3 ww4 ->
                 case w1 of ww5 { Defs.Pkg ww6 ww7 ww8 ww9 ->
                 Defs.$w$c== ww1 ww2 ww3 ww4 ww6 ww7 ww8 ww9 } }) -}
641dcc9c7b6f0085a8ccfe5962bc3941
  $fEqPkg_$s$fEq(,) ::
    GHC.Classes.Eq
      (Defs.PName, (GHC.Types.Bool, Defs.Version, Defs.Version))
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Defs.PName, (GHC.Types.Bool, Defs.Version, Defs.Version))
                  (GHC.Classes.$fEq(,)_$c==
                     @ Defs.PName
                     @ (GHC.Types.Bool, Defs.Version, Defs.Version)
                     Defs.$fEqPName
                     Defs.$fEqPkg_$s$fEq(,,))
                  Defs.$fEqPkg_$s$fEq(,)_$c/= -}
14ef4f43e4a9d12311da1e3aa9839019
  $fEqPkg_$s$fEq(,)_$c/= ::
    (Defs.PName, (GHC.Types.Bool, Defs.Version, Defs.Version))
    -> (Defs.PName, (GHC.Types.Bool, Defs.Version, Defs.Version))
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U,1*U(1*U,1*U,1*U))><S(SL),1*U(1*U,1*U(1*U,1*U,1*U))>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: (Defs.PName,
                          (GHC.Types.Bool, Defs.Version, Defs.Version)))
                   (y :: (Defs.PName,
                          (GHC.Types.Bool, Defs.Version, Defs.Version))) ->
                 case x of wild { (,) a1 a2 ->
                 case y of wild1 { (,) b1 b2 ->
                 case GHC.Base.eqString
                        a1 `cast` (Defs.N:PName[0])
                        b1 `cast` (Defs.N:PName[0]) of wild2 {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True
                   -> case GHC.Classes.$fEq(,,)_$c==
                             @ GHC.Types.Bool
                             @ Defs.Version
                             @ Defs.Version
                             GHC.Classes.$fEqBool
                             Defs.$fEqVersion
                             Defs.$fEqVersion
                             a2
                             b2 of wild3 {
                        GHC.Types.False -> GHC.Types.True
                        GHC.Types.True -> GHC.Types.False } } } }) -}
2fa284e8efd2bb2728f25af2f6cf5f36
  $fEqPkg_$s$fEq(,,) ::
    GHC.Classes.Eq (GHC.Types.Bool, Defs.Version, Defs.Version)
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (GHC.Types.Bool, Defs.Version, Defs.Version)
                  (GHC.Classes.$fEq(,,)_$c==
                     @ GHC.Types.Bool
                     @ Defs.Version
                     @ Defs.Version
                     GHC.Classes.$fEqBool
                     Defs.$fEqVersion
                     Defs.$fEqVersion)
                  Defs.$fEqPkg_$s$fEq(,,)_$c/= -}
d64f7ae437cbc9d938065461f78d24df
  $fEqPkg_$s$fEq(,,)_$c/= ::
    (GHC.Types.Bool, Defs.Version, Defs.Version)
    -> (GHC.Types.Bool, Defs.Version, Defs.Version) -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLL),1*U(1*U,1*U,1*U)><S(SLL),1*U(1*U,1*U,1*U)>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: (GHC.Types.Bool, Defs.Version, Defs.Version))
                   (y :: (GHC.Types.Bool, Defs.Version, Defs.Version)) ->
                 case GHC.Classes.$fEq(,,)_$c==
                        @ GHC.Types.Bool
                        @ Defs.Version
                        @ Defs.Version
                        GHC.Classes.$fEqBool
                        Defs.$fEqVersion
                        Defs.$fEqVersion
                        x
                        y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
357a140a7e8d240bdb378f37a89369a9
  $fEqVNum :: GHC.Classes.Eq Defs.VNum
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Defs.VNum Defs.$fEqVNum_$c== Defs.$fEqVNum_$c/= -}
357a140a7e8d240bdb378f37a89369a9
  $fEqVNum_$c/= :: Defs.VNum -> Defs.VNum -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S)L),1*U(1*U(U),1*U)><S(S(S)L),1*U(1*U(U),1*U)>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: Defs.VNum) (y :: Defs.VNum) ->
                 case x of wild { Defs.VN a1 a2 ->
                 case y of wild1 { Defs.VN b1 b2 ->
                 case GHC.Classes.eqInt a1 b1 of wild2 {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True
                   -> case GHC.Base.eqString a2 b2 of wild3 {
                        GHC.Types.False -> GHC.Types.True
                        GHC.Types.True -> GHC.Types.False } } } }) -}
357a140a7e8d240bdb378f37a89369a9
  $fEqVNum_$c== :: Defs.VNum -> Defs.VNum -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S)L),1*U(1*U(U),1*U)><S(S(S)L),1*U(1*U(U),1*U)>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Defs.VNum) (w1 :: Defs.VNum) ->
                 case w of ww { Defs.VN ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case w1 of ww5 { Defs.VN ww6 ww7 ->
                 case ww6 of ww8 { GHC.Types.I# ww9 ->
                 Defs.$w$c==1 ww4 ww2 ww9 ww7 } } } }) -}
dac81863e92b466ccdd232182575e76a
  $fEqVersion :: GHC.Classes.Eq Defs.Version
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Defs.Version
                  Defs.$fEqVersion1
                    `cast`
                  (Sym (Defs.N:Version[0])
                   ->_R Sym (Defs.N:Version[0])
                   ->_R <GHC.Types.Bool>_R)
                  Defs.$fEqVersion_$s$fEq[]_$c/=
                    `cast`
                  (Sym (Defs.N:Version[0])
                   ->_R Sym (Defs.N:Version[0])
                   ->_R <GHC.Types.Bool>_R) -}
43ec9fa05091d01c30791dffd4320fe5
  $fEqVersion1 :: [Defs.VNum] -> [Defs.VNum] -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Unfolding: (GHC.Classes.$fEq[]_$c== @ Defs.VNum Defs.$fEqVNum) -}
8bf52a0f0ebdc421064b47438bcf49c5
  $fEqVersion_$s$fEq[]_$c/= ::
    [Defs.VNum] -> [Defs.VNum] -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: [Defs.VNum]) (y :: [Defs.VNum]) ->
                 case GHC.Classes.$fEq[]_$c==
                        @ Defs.VNum
                        Defs.$fEqVNum
                        x
                        y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
f57ad031236d47377cee1c770af63619
  $fOrdPName :: GHC.Classes.Ord Defs.PName
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Defs.PName
                  Defs.$fEqPName
                  GHC.Classes.$fOrd[]_$s$ccompare1
                    `cast`
                  (Sym (Defs.N:PName[0])
                   ->_R Sym (Defs.N:PName[0])
                   ->_R <GHC.Types.Ordering>_R)
                  GHC.Classes.$fOrd[]_$s$c<1
                    `cast`
                  (Sym (Defs.N:PName[0])
                   ->_R Sym (Defs.N:PName[0])
                   ->_R <GHC.Types.Bool>_R)
                  GHC.Classes.$fOrd[]_$s$c<=1
                    `cast`
                  (Sym (Defs.N:PName[0])
                   ->_R Sym (Defs.N:PName[0])
                   ->_R <GHC.Types.Bool>_R)
                  GHC.Classes.$fOrd[]_$s$c>1
                    `cast`
                  (Sym (Defs.N:PName[0])
                   ->_R Sym (Defs.N:PName[0])
                   ->_R <GHC.Types.Bool>_R)
                  GHC.Classes.$fOrd[]_$s$c>=1
                    `cast`
                  (Sym (Defs.N:PName[0])
                   ->_R Sym (Defs.N:PName[0])
                   ->_R <GHC.Types.Bool>_R)
                  GHC.Classes.$fOrd[]_$s$cmax1
                    `cast`
                  (Sym (Defs.N:PName[0])
                   ->_R Sym (Defs.N:PName[0])
                   ->_R Sym (Defs.N:PName[0]))
                  GHC.Classes.$fOrd[]_$s$cmin1
                    `cast`
                  (Sym (Defs.N:PName[0])
                   ->_R Sym (Defs.N:PName[0])
                   ->_R Sym (Defs.N:PName[0])) -}
67c0e1532f060e36c08615a4e1246c25
  $fOrdPkg :: GHC.Classes.Ord Defs.Pkg
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Defs.Pkg
                  Defs.$fEqPkg
                  Defs.$fOrdPkg_$ccompare
                  Defs.$fOrdPkg_$c<
                  Defs.$fOrdPkg_$c<=
                  Defs.$fOrdPkg_$c>
                  Defs.$fOrdPkg_$c>=
                  Defs.$fOrdPkg_$cmax
                  Defs.$fOrdPkg_$cmin -}
67c0e1532f060e36c08615a4e1246c25
  $fOrdPkg_$c< :: Defs.Pkg -> Defs.Pkg -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLLL),1*U(U,U,1*U,1*U)><S(SLLL),1*U(U,U,1*U,1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Defs.Pkg) (y :: Defs.Pkg) ->
                 case Defs.$fEqPkg_$c== x y of wild {
                   GHC.Types.False -> Defs.$fOrdPkg_$c<= x y
                   GHC.Types.True -> GHC.Types.False }) -}
67c0e1532f060e36c08615a4e1246c25
  $fOrdPkg_$c<= :: Defs.Pkg -> Defs.Pkg -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLLL),1*U(U,1*U,A,A)><S(SLLL),1*U(U,1*U,A,A)>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Defs.Pkg) (w1 :: Defs.Pkg) ->
                 case w of ww { Defs.Pkg ww1 ww2 ww3 ww4 ->
                 case w1 of ww5 { Defs.Pkg ww6 ww7 ww8 ww9 ->
                 Defs.$w$c<= ww1 ww2 ww6 ww7 } }) -}
67c0e1532f060e36c08615a4e1246c25
  $fOrdPkg_$c> :: Defs.Pkg -> Defs.Pkg -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLLL),1*U(U,U,1*U,1*U)><S(SLLL),1*U(U,U,1*U,1*U)>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Defs.Pkg) (w1 :: Defs.Pkg) ->
                 case w of ww { Defs.Pkg ww1 ww2 ww3 ww4 ->
                 case w1 of ww5 { Defs.Pkg ww6 ww7 ww8 ww9 ->
                 Defs.$w$c> ww1 ww2 ww3 ww4 ww6 ww7 ww8 ww9 } }) -}
67c0e1532f060e36c08615a4e1246c25
  $fOrdPkg_$c>= :: Defs.Pkg -> Defs.Pkg -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLLL),1*U(U,U,1*U,1*U)><S(SLLL),1*U(U,U,1*U,1*U)>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Defs.Pkg) (w1 :: Defs.Pkg) ->
                 case w of ww { Defs.Pkg ww1 ww2 ww3 ww4 ->
                 case w1 of ww5 { Defs.Pkg ww6 ww7 ww8 ww9 ->
                 Defs.$w$c>=1 ww1 ww2 ww3 ww4 ww6 ww7 ww8 ww9 } }) -}
67c0e1532f060e36c08615a4e1246c25
  $fOrdPkg_$ccompare :: Defs.Pkg -> Defs.Pkg -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLLL),1*U(U,U,1*U,1*U)><S(SLLL),1*U(U,U,1*U,1*U)>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Defs.Pkg) (w1 :: Defs.Pkg) ->
                 case w of ww { Defs.Pkg ww1 ww2 ww3 ww4 ->
                 case w1 of ww5 { Defs.Pkg ww6 ww7 ww8 ww9 ->
                 Defs.$w$ccompare1 ww1 ww2 ww3 ww4 ww6 ww7 ww8 ww9 } }) -}
67c0e1532f060e36c08615a4e1246c25
  $fOrdPkg_$cmax :: Defs.Pkg -> Defs.Pkg -> Defs.Pkg
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLLL),1*U(U,U,U,U)><S(SLLL),1*U(U,U,U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Defs.Pkg) (y :: Defs.Pkg) ->
                 case Defs.$fOrdPkg_$c<= x y of wild {
                   GHC.Types.False -> x GHC.Types.True -> y }) -}
67c0e1532f060e36c08615a4e1246c25
  $fOrdPkg_$cmin :: Defs.Pkg -> Defs.Pkg -> Defs.Pkg
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLLL),1*U(U,U,U,U)><S(SLLL),1*U(U,U,U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Defs.Pkg) (y :: Defs.Pkg) ->
                 case Defs.$fOrdPkg_$c<= x y of wild {
                   GHC.Types.False -> y GHC.Types.True -> x }) -}
357a140a7e8d240bdb378f37a89369a9
  $fOrdVNum :: GHC.Classes.Ord Defs.VNum
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Defs.VNum
                  Defs.$fEqVNum
                  Defs.$fOrdVNum_$ccompare
                  Defs.$fOrdVNum_$c<
                  Defs.$fOrdVNum_$c<=
                  Defs.$fOrdVNum_$c>
                  Defs.$fOrdVNum_$c>=
                  Defs.$fOrdVNum_$cmax
                  Defs.$fOrdVNum_$cmin -}
357a140a7e8d240bdb378f37a89369a9
  $fOrdVNum_$c< :: Defs.VNum -> Defs.VNum -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S)L),1*U(1*U(U),1*U)><S(S(S)L),1*U(1*U(U),1*U)>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Defs.VNum) (w1 :: Defs.VNum) ->
                 case w of ww { Defs.VN ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case w1 of ww5 { Defs.VN ww6 ww7 ->
                 case ww6 of ww8 { GHC.Types.I# ww9 ->
                 Defs.$w$c< ww4 ww2 ww9 ww7 } } } }) -}
357a140a7e8d240bdb378f37a89369a9
  $fOrdVNum_$c<= :: Defs.VNum -> Defs.VNum -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S)L),1*U(1*U(U),1*U)><S(S(S)L),1*U(1*U(U),1*U)>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Defs.VNum) (w1 :: Defs.VNum) ->
                 case w of ww { Defs.VN ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case w1 of ww5 { Defs.VN ww6 ww7 ->
                 case ww6 of ww8 { GHC.Types.I# ww9 ->
                 Defs.$w$c<=1 ww4 ww2 ww9 ww7 } } } }) -}
357a140a7e8d240bdb378f37a89369a9
  $fOrdVNum_$c> :: Defs.VNum -> Defs.VNum -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S)L),1*U(1*U(U),1*U)><S(S(S)L),1*U(1*U(U),1*U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (a :: Defs.VNum) (b :: Defs.VNum) -> Defs.$fOrdVNum_$c< b a) -}
357a140a7e8d240bdb378f37a89369a9
  $fOrdVNum_$c>= :: Defs.VNum -> Defs.VNum -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S)L),1*U(1*U(U),1*U)><S(S(S)L),1*U(1*U(U),1*U)>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Defs.VNum) (w1 :: Defs.VNum) ->
                 case w of ww { Defs.VN ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case w1 of ww5 { Defs.VN ww6 ww7 ->
                 case ww6 of ww8 { GHC.Types.I# ww9 ->
                 Defs.$w$c>= ww4 ww2 ww9 ww7 } } } }) -}
357a140a7e8d240bdb378f37a89369a9
  $fOrdVNum_$ccompare :: Defs.VNum -> Defs.VNum -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S)L),1*U(1*U(U),1*U)><S(S(S)L),1*U(1*U(U),1*U)>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Defs.VNum) (w1 :: Defs.VNum) ->
                 case w of ww { Defs.VN ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case w1 of ww5 { Defs.VN ww6 ww7 ->
                 case ww6 of ww8 { GHC.Types.I# ww9 ->
                 Defs.$w$ccompare ww4 ww2 ww9 ww7 } } } }) -}
357a140a7e8d240bdb378f37a89369a9
  $fOrdVNum_$cmax :: Defs.VNum -> Defs.VNum -> Defs.VNum
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S)L),1*U(U(U),U)><S(S(S)L),1*U(U(U),U)>m,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Defs.VNum) (w1 :: Defs.VNum) ->
                 case w of ww { Defs.VN ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case w1 of ww5 { Defs.VN ww6 ww7 ->
                 case ww6 of ww8 { GHC.Types.I# ww9 ->
                 case GHC.Prim.<# ww9 ww4 of lwild {
                   DEFAULT
                   -> case GHC.Prim.==# ww9 ww4 of lwild1 {
                        DEFAULT -> Defs.VN (GHC.Types.I# ww9) ww7
                        1#
                        -> case GHC.Classes.$fOrd[]_$s$ccompare1 ww7 ww2 of wild {
                             DEFAULT -> Defs.VN (GHC.Types.I# ww9) ww7
                             GHC.Types.LT -> Defs.VN (GHC.Types.I# ww4) ww2 } }
                   1# -> Defs.VN (GHC.Types.I# ww4) ww2 } } } } }) -}
357a140a7e8d240bdb378f37a89369a9
  $fOrdVNum_$cmin :: Defs.VNum -> Defs.VNum -> Defs.VNum
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S)L),1*U(U(U),U)><S(S(S)L),1*U(U(U),U)>m,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Defs.VNum) (w1 :: Defs.VNum) ->
                 case w of ww { Defs.VN ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case w1 of ww5 { Defs.VN ww6 ww7 ->
                 case ww6 of ww8 { GHC.Types.I# ww9 ->
                 case GHC.Prim.<# ww9 ww4 of lwild {
                   DEFAULT
                   -> case GHC.Prim.==# ww9 ww4 of lwild1 {
                        DEFAULT -> Defs.VN (GHC.Types.I# ww4) ww2
                        1#
                        -> case GHC.Classes.$fOrd[]_$s$ccompare1 ww7 ww2 of wild {
                             DEFAULT -> Defs.VN (GHC.Types.I# ww4) ww2
                             GHC.Types.LT -> Defs.VN (GHC.Types.I# ww9) ww7 } }
                   1# -> Defs.VN (GHC.Types.I# ww9) ww7 } } } } }) -}
dac81863e92b466ccdd232182575e76a
  $fOrdVersion :: GHC.Classes.Ord Defs.Version
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Defs.Version
                  Defs.$fEqVersion
                  Defs.$fOrdVersion7
                    `cast`
                  (Sym (Defs.N:Version[0])
                   ->_R Sym (Defs.N:Version[0])
                   ->_R <GHC.Types.Ordering>_R)
                  Defs.$fOrdVersion6
                    `cast`
                  (Sym (Defs.N:Version[0])
                   ->_R Sym (Defs.N:Version[0])
                   ->_R <GHC.Types.Bool>_R)
                  Defs.$fOrdVersion5
                    `cast`
                  (Sym (Defs.N:Version[0])
                   ->_R Sym (Defs.N:Version[0])
                   ->_R <GHC.Types.Bool>_R)
                  Defs.$fOrdVersion4
                    `cast`
                  (Sym (Defs.N:Version[0])
                   ->_R Sym (Defs.N:Version[0])
                   ->_R <GHC.Types.Bool>_R)
                  Defs.$fOrdVersion3
                    `cast`
                  (Sym (Defs.N:Version[0])
                   ->_R Sym (Defs.N:Version[0])
                   ->_R <GHC.Types.Bool>_R)
                  Defs.$fOrdVersion2
                    `cast`
                  (Sym (Defs.N:Version[0])
                   ->_R Sym (Defs.N:Version[0])
                   ->_R Sym (Defs.N:Version[0]))
                  Defs.$fOrdVersion1
                    `cast`
                  (Sym (Defs.N:Version[0])
                   ->_R Sym (Defs.N:Version[0])
                   ->_R Sym (Defs.N:Version[0])) -}
fbc4a72506b317c25cdd5f4e95f76aee
  $fOrdVersion1 :: [Defs.VNum] -> [Defs.VNum] -> [Defs.VNum]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: [Defs.VNum]) (y :: [Defs.VNum]) ->
                 case GHC.Classes.$fOrd[]_$ccompare
                        @ Defs.VNum
                        Defs.$fOrdVNum
                        x
                        y of wild {
                   DEFAULT -> x GHC.Types.GT -> y }) -}
cef728ee5a6fe5f5065c40eb5da1c28d
  $fOrdVersion2 :: [Defs.VNum] -> [Defs.VNum] -> [Defs.VNum]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: [Defs.VNum]) (y :: [Defs.VNum]) ->
                 case GHC.Classes.$fOrd[]_$ccompare
                        @ Defs.VNum
                        Defs.$fOrdVNum
                        x
                        y of wild {
                   DEFAULT -> y GHC.Types.GT -> x }) -}
fb35d655c7abea98d91a2931e20fe0dc
  $fOrdVersion3 :: [Defs.VNum] -> [Defs.VNum] -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: [Defs.VNum]) (y :: [Defs.VNum]) ->
                 case GHC.Classes.$fOrd[]_$ccompare
                        @ Defs.VNum
                        Defs.$fOrdVNum
                        x
                        y of wild {
                   DEFAULT -> GHC.Types.True GHC.Types.LT -> GHC.Types.False }) -}
6963b0e28894a1f7d090a02455b84118
  $fOrdVersion4 :: [Defs.VNum] -> [Defs.VNum] -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: [Defs.VNum]) (y :: [Defs.VNum]) ->
                 case GHC.Classes.$fOrd[]_$ccompare
                        @ Defs.VNum
                        Defs.$fOrdVNum
                        x
                        y of wild {
                   DEFAULT -> GHC.Types.False GHC.Types.GT -> GHC.Types.True }) -}
6510d624c8e87eca324dc26839725758
  $fOrdVersion5 :: [Defs.VNum] -> [Defs.VNum] -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: [Defs.VNum]) (y :: [Defs.VNum]) ->
                 case GHC.Classes.$fOrd[]_$ccompare
                        @ Defs.VNum
                        Defs.$fOrdVNum
                        x
                        y of wild {
                   DEFAULT -> GHC.Types.True GHC.Types.GT -> GHC.Types.False }) -}
ea000ab25cd64966fb5b762da13dffe5
  $fOrdVersion6 :: [Defs.VNum] -> [Defs.VNum] -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: [Defs.VNum]) (y :: [Defs.VNum]) ->
                 case GHC.Classes.$fOrd[]_$ccompare
                        @ Defs.VNum
                        Defs.$fOrdVNum
                        x
                        y of wild {
                   DEFAULT -> GHC.Types.False GHC.Types.LT -> GHC.Types.True }) -}
feee11a430b8142ef981bee9b697200e
  $fOrdVersion7 :: [Defs.VNum] -> [Defs.VNum] -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs,
     Unfolding: (GHC.Classes.$fOrd[]_$ccompare
                   @ Defs.VNum
                   Defs.$fOrdVNum) -}
f1583a426d94974bff3b76eacb5d8923
  $fReadDatabase :: GHC.Read.Read Defs.Database
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Defs.Database
                  Defs.$fReadDatabase_$creadsPrec
                  Defs.$fReadDatabase_$creadList
                  Defs.$fReadDatabase1
                    `cast`
                  ((<Text.ParserCombinators.ReadPrec.Prec>_R
                    ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                  <Defs.Database>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                 <Defs.Database>_R))
                  Defs.$fReadDatabase_$creadListPrec -}
f1583a426d94974bff3b76eacb5d8923
  $fReadDatabase1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Defs.Database -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2,
     Unfolding: (GHC.Read.$fRead()6
                   @ Defs.Database
                   Defs.$fReadDatabase2
                     `cast`
                   ((<Text.ParserCombinators.ReadPrec.Prec>_R
                     ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                   <Defs.Database>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                  <Defs.Database>_R))) -}
f1583a426d94974bff3b76eacb5d8923
  $fReadDatabase2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Defs.Database -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <S(S),1*U(U)><L,C(U)>, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (w1 :: Defs.Database -> Text.ParserCombinators.ReadP.P b) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Defs.$w$creadPrec ww1 @ b w1 }) -}
d8c2204745ff608e6fe67a1170d51575
  $fReadDatabase3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Defs.$fReadDatabase4) -}
2966455848dcf642aa9047c9bca3e12d
  $fReadDatabase4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("DB"#) -}
52b4cbc083fe2cad9141f813d0fb24fd
  $fReadDatabase5 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 11#) -}
67c0e1532f060e36c08615a4e1246c25
  $fReadDatabase6 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Defs.Pkg -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2,
     Unfolding: (GHC.Read.$fRead()6
                   @ Defs.Pkg
                   Defs.$fReadDatabase7
                     `cast`
                   ((<Text.ParserCombinators.ReadPrec.Prec>_R
                     ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                   <Defs.Pkg>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                             <Defs.Pkg>_R))) -}
67c0e1532f060e36c08615a4e1246c25
  $fReadDatabase7 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Defs.Pkg -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <S(S),1*U(U)><L,C(U)>, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (w1 :: Defs.Pkg -> Text.ParserCombinators.ReadP.P b) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Defs.$w$creadPrec1 ww1 @ b w1 }) -}
f1583a426d94974bff3b76eacb5d8923
  $fReadDatabase8 :: Text.ParserCombinators.ReadP.P [Defs.Database]
  {- Unfolding: ((Defs.$fReadDatabase_$creadListPrec
                    `cast`
                  (Text.ParserCombinators.ReadPrec.N:ReadPrec[0] <[Defs.Database]>_R)
                    GHC.Read.$fRead()8)
                   `cast`
                 (Text.ParserCombinators.ReadP.N:ReadP[0] <[Defs.Database]>_R)
                   @ [Defs.Database]
                   (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                      @ [Defs.Database])) -}
f1583a426d94974bff3b76eacb5d8923
  $fReadDatabase_$creadList ::
    Text.ParserCombinators.ReadP.ReadS [Defs.Database]
  {- Arity: 1,
     Unfolding: (Text.ParserCombinators.ReadP.run
                   @ [Defs.Database]
                   Defs.$fReadDatabase8) -}
f1583a426d94974bff3b76eacb5d8923
  $fReadDatabase_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [Defs.Database]
  {- Unfolding: (GHC.Read.list
                   @ Defs.Database
                   Defs.$fReadDatabase1
                     `cast`
                   ((<Text.ParserCombinators.ReadPrec.Prec>_R
                     ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                   <Defs.Database>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                  <Defs.Database>_R))) -}
67c0e1532f060e36c08615a4e1246c25
  $fReadDatabase_$creadListPrec1 ::
    Text.ParserCombinators.ReadPrec.ReadPrec [Defs.Pkg]
  {- Unfolding: (GHC.Read.list
                   @ Defs.Pkg
                   Defs.$fReadDatabase6
                     `cast`
                   ((<Text.ParserCombinators.ReadPrec.Prec>_R
                     ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                   <Defs.Pkg>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                             <Defs.Pkg>_R))) -}
f1583a426d94974bff3b76eacb5d8923
  $fReadDatabase_$creadsPrec ::
    GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS Defs.Database
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (n :: GHC.Types.Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ Defs.Database
                   (GHC.Read.$fRead()6
                      @ Defs.Database
                      Defs.$fReadDatabase2
                        `cast`
                      ((<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Defs.Database>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                     <Defs.Database>_R))
                      n
                      @ Defs.Database
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ Defs.Database))) -}
f57ad031236d47377cee1c770af63619
  $fReadPName :: GHC.Read.Read Defs.PName
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Defs.PName
                  Defs.$fReadPName_$creadsPrec
                  Defs.$fReadPName_$creadList
                  Defs.$fReadPName1
                    `cast`
                  ((<Text.ParserCombinators.ReadPrec.Prec>_R
                    ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                  <Defs.PName>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                              <Defs.PName>_R))
                  Defs.$fReadPName_$creadListPrec -}
f57ad031236d47377cee1c770af63619
  $fReadPName1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Defs.PName -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2,
     Unfolding: (GHC.Read.$fRead()6
                   @ Defs.PName
                   Defs.$fReadPName2
                     `cast`
                   ((<Text.ParserCombinators.ReadPrec.Prec>_R
                     ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                   <Defs.PName>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                               <Defs.PName>_R))) -}
f57ad031236d47377cee1c770af63619
  $fReadPName2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Defs.PName -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <S(S),1*U(U)><L,C(U)>, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (w1 :: Defs.PName -> Text.ParserCombinators.ReadP.P b) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Defs.$w$creadPrec2 ww1 @ b w1 }) -}
130425c2e2f801069913ba0a7dcbc5ad
  $fReadPName3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Defs.$fReadPName4) -}
a90e5a19264fb0123275c7b7686e94bc
  $fReadPName4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("P"#) -}
f57ad031236d47377cee1c770af63619
  $fReadPName5 :: Text.ParserCombinators.ReadP.P [Defs.PName]
  {- Unfolding: ((Defs.$fReadPName_$creadListPrec
                    `cast`
                  (Text.ParserCombinators.ReadPrec.N:ReadPrec[0] <[Defs.PName]>_R)
                    GHC.Read.$fRead()8)
                   `cast`
                 (Text.ParserCombinators.ReadP.N:ReadP[0] <[Defs.PName]>_R)
                   @ [Defs.PName]
                   (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                      @ [Defs.PName])) -}
f57ad031236d47377cee1c770af63619
  $fReadPName_$creadList ::
    Text.ParserCombinators.ReadP.ReadS [Defs.PName]
  {- Arity: 1,
     Unfolding: (Text.ParserCombinators.ReadP.run
                   @ [Defs.PName]
                   Defs.$fReadPName5) -}
f57ad031236d47377cee1c770af63619
  $fReadPName_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [Defs.PName]
  {- Unfolding: (GHC.Read.list
                   @ Defs.PName
                   Defs.$fReadPName1
                     `cast`
                   ((<Text.ParserCombinators.ReadPrec.Prec>_R
                     ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                   <Defs.PName>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                               <Defs.PName>_R))) -}
f57ad031236d47377cee1c770af63619
  $fReadPName_$creadsPrec ::
    GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS Defs.PName
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (n :: GHC.Types.Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ Defs.PName
                   (GHC.Read.$fRead()6
                      @ Defs.PName
                      Defs.$fReadPName2
                        `cast`
                      ((<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Defs.PName>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                  <Defs.PName>_R))
                      n
                      @ Defs.PName
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ Defs.PName))) -}
67c0e1532f060e36c08615a4e1246c25
  $fReadPkg :: GHC.Read.Read Defs.Pkg
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Defs.Pkg
                  Defs.$fReadPkg_$creadsPrec
                  Defs.$fReadPkg_$creadList
                  Defs.$fReadDatabase6
                    `cast`
                  ((<Text.ParserCombinators.ReadPrec.Prec>_R
                    ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                  <Defs.Pkg>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                            <Defs.Pkg>_R))
                  Defs.$fReadDatabase_$creadListPrec1 -}
67c0e1532f060e36c08615a4e1246c25
  $fReadPkg1 :: Text.ParserCombinators.ReadP.P [Defs.Pkg]
  {- Unfolding: ((Defs.$fReadDatabase_$creadListPrec1
                    `cast`
                  (Text.ParserCombinators.ReadPrec.N:ReadPrec[0] <[Defs.Pkg]>_R)
                    GHC.Read.$fRead()8)
                   `cast`
                 (Text.ParserCombinators.ReadP.N:ReadP[0] <[Defs.Pkg]>_R)
                   @ [Defs.Pkg]
                   (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                      @ [Defs.Pkg])) -}
67c0e1532f060e36c08615a4e1246c25
  $fReadPkg_$creadList ::
    Text.ParserCombinators.ReadP.ReadS [Defs.Pkg]
  {- Arity: 1,
     Unfolding: (Text.ParserCombinators.ReadP.run
                   @ [Defs.Pkg]
                   Defs.$fReadPkg1) -}
67c0e1532f060e36c08615a4e1246c25
  $fReadPkg_$creadsPrec ::
    GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS Defs.Pkg
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (n :: GHC.Types.Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ Defs.Pkg
                   (GHC.Read.$fRead()6
                      @ Defs.Pkg
                      Defs.$fReadDatabase7
                        `cast`
                      ((<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Defs.Pkg>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                <Defs.Pkg>_R))
                      n
                      @ Defs.Pkg
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ Defs.Pkg))) -}
357a140a7e8d240bdb378f37a89369a9
  $fReadVNum :: GHC.Read.Read Defs.VNum
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Defs.VNum
                  Defs.$fReadVNum_$creadsPrec
                  Defs.$fReadVNum_$creadList
                  Defs.$fReadVNum1
                    `cast`
                  ((<Text.ParserCombinators.ReadPrec.Prec>_R
                    ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                  <Defs.VNum>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                             <Defs.VNum>_R))
                  Defs.$fReadVNum_$creadListPrec -}
357a140a7e8d240bdb378f37a89369a9
  $fReadVNum1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Defs.VNum -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2,
     Unfolding: (GHC.Read.$fRead()6
                   @ Defs.VNum
                   Defs.$fReadVNum2
                     `cast`
                   ((<Text.ParserCombinators.ReadPrec.Prec>_R
                     ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                   <Defs.VNum>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                              <Defs.VNum>_R))) -}
357a140a7e8d240bdb378f37a89369a9
  $fReadVNum2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Defs.VNum -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <S(S),1*U(U)><L,C(U)>, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (w1 :: Defs.VNum -> Text.ParserCombinators.ReadP.P b) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Defs.$w$creadPrec3 ww1 @ b w1 }) -}
3fff59ec6cc1307ae6d61abc71e0ef96
  $fReadVNum3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Defs.$fReadVNum4) -}
5b7d63d14f929e3c1dbd9d3d40e512fc
  $fReadVNum4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("VN"#) -}
357a140a7e8d240bdb378f37a89369a9
  $fReadVNum5 :: Text.ParserCombinators.ReadP.P [Defs.VNum]
  {- Unfolding: ((Defs.$fReadVNum_$creadListPrec
                    `cast`
                  (Text.ParserCombinators.ReadPrec.N:ReadPrec[0] <[Defs.VNum]>_R)
                    GHC.Read.$fRead()8)
                   `cast`
                 (Text.ParserCombinators.ReadP.N:ReadP[0] <[Defs.VNum]>_R)
                   @ [Defs.VNum]
                   (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                      @ [Defs.VNum])) -}
357a140a7e8d240bdb378f37a89369a9
  $fReadVNum_$creadList ::
    Text.ParserCombinators.ReadP.ReadS [Defs.VNum]
  {- Arity: 1,
     Unfolding: (Text.ParserCombinators.ReadP.run
                   @ [Defs.VNum]
                   Defs.$fReadVNum5) -}
357a140a7e8d240bdb378f37a89369a9
  $fReadVNum_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [Defs.VNum]
  {- Unfolding: (GHC.Read.list
                   @ Defs.VNum
                   Defs.$fReadVNum1
                     `cast`
                   ((<Text.ParserCombinators.ReadPrec.Prec>_R
                     ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                   <Defs.VNum>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                              <Defs.VNum>_R))) -}
357a140a7e8d240bdb378f37a89369a9
  $fReadVNum_$creadsPrec ::
    GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS Defs.VNum
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (n :: GHC.Types.Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ Defs.VNum
                   (GHC.Read.$fRead()6
                      @ Defs.VNum
                      Defs.$fReadVNum2
                        `cast`
                      ((<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Defs.VNum>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                 <Defs.VNum>_R))
                      n
                      @ Defs.VNum
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ Defs.VNum))) -}
dac81863e92b466ccdd232182575e76a
  $fReadVersion :: GHC.Read.Read Defs.Version
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Defs.Version
                  Defs.$fReadVersion_$creadsPrec
                  Defs.$fReadVersion_$creadList
                  Defs.$fReadVersion1
                    `cast`
                  ((<Text.ParserCombinators.ReadPrec.Prec>_R
                    ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                  <Defs.Version>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                <Defs.Version>_R))
                  Defs.$fReadVersion_$creadListPrec -}
dac81863e92b466ccdd232182575e76a
  $fReadVersion1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Defs.Version -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2,
     Unfolding: (GHC.Read.$fRead()6
                   @ Defs.Version
                   Defs.$fReadVersion2
                     `cast`
                   ((<Text.ParserCombinators.ReadPrec.Prec>_R
                     ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                   <Defs.Version>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                 <Defs.Version>_R))) -}
dac81863e92b466ccdd232182575e76a
  $fReadVersion2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Defs.Version -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <S(S),1*U(U)><L,C(U)>, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (w1 :: Defs.Version -> Text.ParserCombinators.ReadP.P b) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Defs.$w$creadPrec4 ww1 @ b w1 }) -}
dc0847ba9d1977fbac85dc2ea6582aa1
  $fReadVersion3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Defs.$fReadVersion4) -}
a1ae44e4dd9d07132943ef3fbba5599c
  $fReadVersion4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("V"#) -}
dac81863e92b466ccdd232182575e76a
  $fReadVersion5 :: Text.ParserCombinators.ReadP.P [Defs.Version]
  {- Unfolding: ((Defs.$fReadVersion_$creadListPrec
                    `cast`
                  (Text.ParserCombinators.ReadPrec.N:ReadPrec[0] <[Defs.Version]>_R)
                    GHC.Read.$fRead()8)
                   `cast`
                 (Text.ParserCombinators.ReadP.N:ReadP[0] <[Defs.Version]>_R)
                   @ [Defs.Version]
                   (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                      @ [Defs.Version])) -}
dac81863e92b466ccdd232182575e76a
  $fReadVersion_$creadList ::
    Text.ParserCombinators.ReadP.ReadS [Defs.Version]
  {- Arity: 1,
     Unfolding: (Text.ParserCombinators.ReadP.run
                   @ [Defs.Version]
                   Defs.$fReadVersion5) -}
dac81863e92b466ccdd232182575e76a
  $fReadVersion_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [Defs.Version]
  {- Unfolding: (GHC.Read.list
                   @ Defs.Version
                   Defs.$fReadVersion1
                     `cast`
                   ((<Text.ParserCombinators.ReadPrec.Prec>_R
                     ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                   <Defs.Version>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                 <Defs.Version>_R))) -}
dac81863e92b466ccdd232182575e76a
  $fReadVersion_$creadsPrec ::
    GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS Defs.Version
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (n :: GHC.Types.Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ Defs.Version
                   (GHC.Read.$fRead()6
                      @ Defs.Version
                      Defs.$fReadVersion2
                        `cast`
                      ((<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Defs.Version>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                    <Defs.Version>_R))
                      n
                      @ Defs.Version
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ Defs.Version))) -}
f1583a426d94974bff3b76eacb5d8923
  $fShowDatabase :: GHC.Show.Show Defs.Database
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Defs.Database
                  Defs.$fShowDatabase_$cshowsPrec
                  Defs.prettyPkgs
                    `cast`
                  (Sym (Defs.N:Database[0]) ->_R <GHC.Base.String>_R)
                  Defs.$fShowDatabase_$cshowList -}
f1583a426d94974bff3b76eacb5d8923
  $fShowDatabase1 ::
    Defs.Database -> GHC.Base.String -> [GHC.Types.Char]
  {- Arity: 2, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Defs.Database) (s :: GHC.Base.String)[OneShot] ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b
                      (c :: GHC.Types.Char -> b -> b)[OneShot]
                      (n :: b)[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      c
                      n
                      (Defs.prettyPkgs x `cast` (Defs.N:Database[0])))
                   s) -}
f1583a426d94974bff3b76eacb5d8923
  $fShowDatabase_$cshowList :: [Defs.Database] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [Defs.Database]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__ @ Defs.Database Defs.$fShowDatabase1 ls s) -}
f1583a426d94974bff3b76eacb5d8923
  $fShowDatabase_$cshowsPrec ::
    GHC.Types.Int -> Defs.Database -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ds3 :: GHC.Types.Int)
                   (x :: Defs.Database)
                   (s :: GHC.Base.String) ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b
                      (c :: GHC.Types.Char -> b -> b)[OneShot]
                      (n :: b)[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      c
                      n
                      (Defs.prettyPkgs x `cast` (Defs.N:Database[0])))
                   s) -}
f57ad031236d47377cee1c770af63619
  $fShowPName :: GHC.Show.Show Defs.PName
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Defs.PName
                  Defs.$fShowPName_$cshowsPrec
                  Defs.$fShowPName_$cshow
                  Defs.$fShowPName_$cshowList -}
f57ad031236d47377cee1c770af63619
  $fShowPName1 :: Defs.PName -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <L,1*U><L,U>,
     Unfolding: (\ (w :: Defs.PName) (w1 :: GHC.Base.String) ->
                 Defs.$w$cshowsPrec 0# w w1) -}
b3a85ab4ff94eef47fc65ead6e2d23d5
  $fShowPName2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("P "#) -}
f57ad031236d47377cee1c770af63619
  $fShowPName_$cshow :: Defs.PName -> GHC.Base.String
  {- Arity: 1, Strictness: <L,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Defs.PName) ->
                 GHC.CString.unpackAppendCString#
                   Defs.$fShowPName2
                   (GHC.Types.:
                      @ GHC.Types.Char
                      GHC.Show.$fShow(,)3
                      (GHC.Show.showLitString
                         x `cast` (Defs.N:PName[0])
                         (GHC.Types.:
                            @ GHC.Types.Char
                            GHC.Show.$fShow(,)3
                            (GHC.Types.[] @ GHC.Types.Char))))) -}
f57ad031236d47377cee1c770af63619
  $fShowPName_$cshowList :: [Defs.PName] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [Defs.PName]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__ @ Defs.PName Defs.$fShowPName1 ls s) -}
f57ad031236d47377cee1c770af63619
  $fShowPName_$cshowsPrec ::
    GHC.Types.Int -> Defs.PName -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S(S),1*U(U)><L,1*U><L,U>, Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Defs.PName)
                   (w2 :: GHC.Base.String) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Defs.$w$cshowsPrec ww1 w1 w2 }) -}
67c0e1532f060e36c08615a4e1246c25
  $fShowPkg :: GHC.Show.Show Defs.Pkg
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Defs.Pkg
                  Defs.$fShowPkg_$cshowsPrec
                  Defs.$fShowPkg_$cshow
                  Defs.$fShowPkg_$cshowList -}
67c0e1532f060e36c08615a4e1246c25
  $fShowPkg1 :: Defs.Pkg -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U(1*U,1*U,1*U,1*U)><L,U>,
     Unfolding: (\ (w :: Defs.Pkg) (w1 :: GHC.Base.String) ->
                 case w of ww { Defs.Pkg ww1 ww2 ww3 ww4 ->
                 Defs.$w$cshowsPrec1 0# ww1 ww2 ww3 ww4 w1 }) -}
b98262972522b9a850df9d5fae33d55a
  $fShowPkg2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
67c0e1532f060e36c08615a4e1246c25
  $fShowPkg_$cshow :: Defs.Pkg -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U,1*U,1*U,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Defs.Pkg) ->
                 Defs.$fShowPkg_$cshowsPrec
                   Defs.$fShowPkg2
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
67c0e1532f060e36c08615a4e1246c25
  $fShowPkg_$cshowList :: [Defs.Pkg] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [Defs.Pkg]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__ @ Defs.Pkg Defs.$fShowPkg1 ls s) -}
67c0e1532f060e36c08615a4e1246c25
  $fShowPkg_$cshowsPrec ::
    GHC.Types.Int -> Defs.Pkg -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <S(S),1*U(U)><S,1*U(1*U,1*U,1*U,1*U)><L,U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: Defs.Pkg) (w2 :: GHC.Base.String) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Defs.Pkg ww3 ww4 ww5 ww6 ->
                 Defs.$w$cshowsPrec1 ww1 ww3 ww4 ww5 ww6 w2 } }) -}
357a140a7e8d240bdb378f37a89369a9
  $fShowVNum :: GHC.Show.Show Defs.VNum
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Defs.VNum
                  Defs.$fShowVNum_$cshowsPrec
                  Defs.$fShowVNum_$cshow
                  Defs.$fShowVNum_$cshowList -}
357a140a7e8d240bdb378f37a89369a9
  $fShowVNum1 :: Defs.VNum -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U(1*U(U),1*U)><L,U>,
     Unfolding: (\ (w :: Defs.VNum) (w1 :: GHC.Base.String) ->
                 case w of ww { Defs.VN ww1 ww2 ->
                 Defs.$w$cshowsPrec2 0# ww1 ww2 w1 }) -}
bc704318114a3f34a01930e1bb178b00
  $fShowVNum2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("VN "#) -}
acf08d132376f6039d30ffbcd9044f63
  $fShowVNum3 :: [GHC.Types.Char]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Char
                   GHC.Show.$fShow(,)3
                   (GHC.Types.[] @ GHC.Types.Char)) -}
357a140a7e8d240bdb378f37a89369a9
  $fShowVNum_$cshow :: Defs.VNum -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U(U),1*U)>, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Defs.VNum) ->
                 case w of ww { Defs.VN ww1 ww2 -> Defs.$w$cshow ww1 ww2 }) -}
357a140a7e8d240bdb378f37a89369a9
  $fShowVNum_$cshowList :: [Defs.VNum] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [Defs.VNum]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__ @ Defs.VNum Defs.$fShowVNum1 ls s) -}
357a140a7e8d240bdb378f37a89369a9
  $fShowVNum_$cshowsPrec ::
    GHC.Types.Int -> Defs.VNum -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S(S),1*U(U)><S,1*U(1*U(U),1*U)><L,U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Defs.VNum)
                   (w2 :: GHC.Base.String) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Defs.VN ww3 ww4 ->
                 Defs.$w$cshowsPrec2 ww1 ww3 ww4 w2 } }) -}
dac81863e92b466ccdd232182575e76a
  $fShowVersion :: GHC.Show.Show Defs.Version
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Defs.Version
                  Defs.$fShowVersion_$cshowsPrec
                  Defs.$fShowVersion_$cshow
                  Defs.$fShowVersion_$cshowList -}
dac81863e92b466ccdd232182575e76a
  $fShowVersion1 :: Defs.Version -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <L,1*U><L,U>,
     Unfolding: (\ (w :: Defs.Version) (w1 :: GHC.Base.String) ->
                 Defs.$w$cshowsPrec3 0# w w1) -}
eec0c558417ff09a74e796e1082ef4fd
  $fShowVersion2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("V "#) -}
2d0c6eafdc876003ace0eb90041dfca3
  $fShowVersion3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackAppendCString#
                   GHC.Show.showList__4
                   (GHC.Types.[] @ GHC.Types.Char)) -}
dac81863e92b466ccdd232182575e76a
  $fShowVersion_$cshow :: Defs.Version -> GHC.Base.String
  {- Arity: 1, Strictness: <L,1*U>,
     Unfolding: (\ (x :: Defs.Version) ->
                 GHC.CString.unpackAppendCString#
                   Defs.$fShowVersion2
                   (case x `cast` (Defs.N:Version[0]) of wild {
                      [] -> Defs.$fShowVersion3
                      : x1 xs
                      -> GHC.Types.:
                           @ GHC.Types.Char
                           GHC.Show.showList__3
                           (case x1 of wild1 { Defs.VN b1 b2 ->
                            GHC.CString.unpackAppendCString#
                              Defs.$fShowVNum2
                              (case b1 of ww2 { GHC.Types.I# ww3 ->
                               case GHC.Show.$wshowSignedInt
                                      11#
                                      ww3
                                      (GHC.Types.:
                                         @ GHC.Types.Char
                                         GHC.Show.showSpace1
                                         (GHC.Types.:
                                            @ GHC.Types.Char
                                            GHC.Show.$fShow(,)3
                                            (GHC.Show.showLitString
                                               b2
                                               (GHC.Types.:
                                                  @ GHC.Types.Char
                                                  GHC.Show.$fShow(,)3
                                                  (Defs.$fShowVersion_showl
                                                     xs))))) of ww4 { (#,#) ww5 ww6 ->
                               GHC.Types.: @ GHC.Types.Char ww5 ww6 } }) }) })) -}
dac81863e92b466ccdd232182575e76a
  $fShowVersion_$cshowList :: [Defs.Version] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [Defs.Version]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__ @ Defs.Version Defs.$fShowVersion1 ls s) -}
dac81863e92b466ccdd232182575e76a
  $fShowVersion_$cshowsPrec ::
    GHC.Types.Int -> Defs.Version -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S(S),1*U(U)><L,1*U><L,U>, Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Defs.Version)
                   (w2 :: GHC.Base.String) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Defs.$w$cshowsPrec3 ww1 w1 w2 }) -}
8706b1e65546f3fb70d5760b087d34fe
  $fShowVersion_showl :: [Defs.VNum] -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>m2 -}
73058cc42736be0edf22afe0d5ee3c9c
  $s$fRead(,,) ::
    GHC.Read.Read (GHC.Types.Bool, Defs.Version, Defs.Version)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (GHC.Types.Bool, Defs.Version, Defs.Version)
                  (\ (n :: GHC.Types.Int) ->
                   Text.ParserCombinators.ReadP.run
                     @ (GHC.Types.Bool, Defs.Version, Defs.Version)
                     (GHC.Read.$fRead(,,)1
                        @ GHC.Types.Bool
                        @ Defs.Version
                        @ Defs.Version
                        GHC.Read.$fReadBool
                        Defs.$fReadVersion
                        Defs.$fReadVersion
                        n
                        @ (GHC.Types.Bool, Defs.Version, Defs.Version)
                        (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                           @ (GHC.Types.Bool, Defs.Version, Defs.Version))))
                  (Text.ParserCombinators.ReadP.run
                     @ [(GHC.Types.Bool, Defs.Version, Defs.Version)]
                     (((GHC.Read.list
                          @ (GHC.Types.Bool, Defs.Version, Defs.Version)
                          (GHC.Read.$fRead(,,)1
                             @ GHC.Types.Bool
                             @ Defs.Version
                             @ Defs.Version
                             GHC.Read.$fReadBool
                             Defs.$fReadVersion
                             Defs.$fReadVersion)
                            `cast`
                          ((<Text.ParserCombinators.ReadPrec.Prec>_R
                            ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                          <(GHC.Types.Bool, Defs.Version,
                                            Defs.Version)>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                          <(GHC.Types.Bool,
                                                                            Defs.Version,
                                                                            Defs.Version)>_R)))
                         `cast`
                       (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                            <[(GHC.Types.Bool, Defs.Version, Defs.Version)]>_R)
                         GHC.Read.$fRead()8)
                        `cast`
                      (Text.ParserCombinators.ReadP.N:ReadP[0]
                           <[(GHC.Types.Bool, Defs.Version, Defs.Version)]>_R)
                        @ [(GHC.Types.Bool, Defs.Version, Defs.Version)]
                        (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                           @ [(GHC.Types.Bool, Defs.Version, Defs.Version)])))
                  (GHC.Read.$fRead(,,)1
                     @ GHC.Types.Bool
                     @ Defs.Version
                     @ Defs.Version
                     GHC.Read.$fReadBool
                     Defs.$fReadVersion
                     Defs.$fReadVersion)
                    `cast`
                  ((<Text.ParserCombinators.ReadPrec.Prec>_R
                    ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                  <(GHC.Types.Bool, Defs.Version,
                                    Defs.Version)>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                  <(GHC.Types.Bool, Defs.Version,
                                                                    Defs.Version)>_R))
                  (GHC.Read.list
                     @ (GHC.Types.Bool, Defs.Version, Defs.Version)
                     (GHC.Read.$fRead(,,)1
                        @ GHC.Types.Bool
                        @ Defs.Version
                        @ Defs.Version
                        GHC.Read.$fReadBool
                        Defs.$fReadVersion
                        Defs.$fReadVersion)
                       `cast`
                     ((<Text.ParserCombinators.ReadPrec.Prec>_R
                       ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                     <(GHC.Types.Bool, Defs.Version,
                                       Defs.Version)>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                     <(GHC.Types.Bool, Defs.Version,
                                                                       Defs.Version)>_R))) -}
c2d08c352e4cc97b890c63e39d2bf2a7
  $s$fRead(,,)_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec
      [(GHC.Types.Bool, Defs.Version, Defs.Version)]
  {- Unfolding: InlineRule (0, True, False)
                (GHC.Read.list
                   @ (GHC.Types.Bool, Defs.Version, Defs.Version)
                   (GHC.Read.$fRead(,,)1
                      @ GHC.Types.Bool
                      @ Defs.Version
                      @ Defs.Version
                      GHC.Read.$fReadBool
                      Defs.$fReadVersion
                      Defs.$fReadVersion)
                     `cast`
                   ((<Text.ParserCombinators.ReadPrec.Prec>_R
                     ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                   <(GHC.Types.Bool, Defs.Version,
                                     Defs.Version)>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                   <(GHC.Types.Bool, Defs.Version,
                                                                     Defs.Version)>_R))) -}
f159b938272920f7a886fe1396ae5934
  $s$fRead(,,)_$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS
         (GHC.Types.Bool, Defs.Version, Defs.Version)
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (n :: GHC.Types.Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ (GHC.Types.Bool, Defs.Version, Defs.Version)
                   (GHC.Read.$fRead(,,)1
                      @ GHC.Types.Bool
                      @ Defs.Version
                      @ Defs.Version
                      GHC.Read.$fReadBool
                      Defs.$fReadVersion
                      Defs.$fReadVersion
                      n
                      @ (GHC.Types.Bool, Defs.Version, Defs.Version)
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ (GHC.Types.Bool, Defs.Version, Defs.Version)))) -}
9fc9818397b0c8be2f3453ed856f5998
  $sconcatMap :: (a -> [b]) -> [a] -> [b]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ a @ b (f2 :: a -> [b]) (xs :: [a]) ->
                 GHC.Base.build
                   @ b
                   (\ @ b1 (c :: b -> b1 -> b1)[OneShot] (n :: b1)[OneShot] ->
                    GHC.Base.foldr
                      @ a
                      @ b1
                      (\ (x :: a) (b2 :: b1)[OneShot] ->
                       GHC.Base.foldr @ b @ b1 c b2 (f2 x))
                      n
                      xs)) -}
d047bb0188ff6d488a01de217dbb97c2
  $tc'DB :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6710150560895109992##
                   4181890489993944464##
                   Defs.$trModule
                   Defs.$tc'DB2
                   0#
                   Defs.$tc'DB1) -}
4295fa4fa8e438270f682a57ecfeb993
  $tc'DB1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
39ef23ff390d5eb5ea635ad12725d59a
  $tc'DB2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Defs.$tc'DB3) -}
c261e83abf1343e8a3822ffc9d34bd07
  $tc'DB3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'DB"#) -}
2179971a37de59f893dcd63740e482d0
  $tc'P :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1895060723845953775##
                   13239575696791328392##
                   Defs.$trModule
                   Defs.$tc'P2
                   0#
                   Defs.$tc'P1) -}
84d734250358cdbe1ff22b22b8515b6e
  $tc'P1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
1d52e78be82ea33250c91a364991f666
  $tc'P2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Defs.$tc'P3) -}
a91ccd0809d31769abb57f17cb60329e
  $tc'P3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'P"#) -}
20d15543b92f1d02dcc065c5b8319d9d
  $tc'Pkg :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9628754117690000581##
                   15108100868313471917##
                   Defs.$trModule
                   Defs.$tc'Pkg2
                   0#
                   Defs.$tc'Pkg1) -}
672b8e1f650307012cc4dba0462f5b5d
  $tc'Pkg1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
649ab7a14816d736385e901d1db5ba02
  $tc'Pkg2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Defs.$tc'Pkg3) -}
08f42546c6a5ed1d4c68600992bfaebc
  $tc'Pkg3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Pkg"#) -}
828a3b9a2c17a39487cdd030096a9ba4
  $tc'V :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9932928455338860515##
                   2265167818359246385##
                   Defs.$trModule
                   Defs.$tc'V2
                   0#
                   Defs.$tc'V1) -}
933c115a8881595bd572052ad22961e3
  $tc'V1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
debf0ece3471d79f4cd07e12fab93f46
  $tc'V2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Defs.$tc'V3) -}
735cd0b0b0461ca75cb7801e7672991e
  $tc'V3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'V"#) -}
54567c4795a9bee4593e77c4a14fbe30
  $tc'VN :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16045062040044185826##
                   9465207218894002550##
                   Defs.$trModule
                   Defs.$tc'VN2
                   0#
                   Defs.$tc'VN1) -}
51886f82af445d88cd80bdc7f50874e3
  $tc'VN1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
acac809b25bd0668d4383e68b315ab78
  $tc'VN2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Defs.$tc'VN3) -}
5d3f4f0881b45604d97888730c850a16
  $tc'VN3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'VN"#) -}
12e6428ee4025df122da41b627b317a8
  $tcDatabase :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13658341621504567247##
                   3273093268611965992##
                   Defs.$trModule
                   Defs.$tcDatabase1
                   0#
                   GHC.Types.krep$*) -}
64c866f0c66e15c14868c8a62bd1142f
  $tcDatabase1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Defs.$tcDatabase2) -}
6edce30e01479298c98cec975592f9af
  $tcDatabase2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Database"#) -}
336302a4d388b787f39f54416363ea90
  $tcPName :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10511558133572589068##
                   4406919698634664543##
                   Defs.$trModule
                   Defs.$tcPName1
                   0#
                   GHC.Types.krep$*) -}
55068f073eee83f90df0a243f24aae83
  $tcPName1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Defs.$tcPName2) -}
163950534cee12147461aedec5002598
  $tcPName2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("PName"#) -}
9f6ff4fa84230d84901799ad71ad51a6
  $tcPkg :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2496386105190687736##
                   9674392796912296427##
                   Defs.$trModule
                   Defs.$tcPkg1
                   0#
                   GHC.Types.krep$*) -}
cd720a0023abaa4115505b27d1d92490
  $tcPkg1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Defs.$tcPkg2) -}
2b0cb72657109b648ce983046226646d
  $tcPkg2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Pkg"#) -}
acf708ccc7c680f5d834ba0cea868f15
  $tcVNum :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9386515932498851910##
                   3640794616966595094##
                   Defs.$trModule
                   Defs.$tcVNum1
                   0#
                   GHC.Types.krep$*) -}
eff39b8b852fcd4f7aacab1edb75ad5b
  $tcVNum1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Defs.$tcVNum2) -}
ab5c0f216e9433c128ff410c5af44015
  $tcVNum2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("VNum"#) -}
ccf5b47049339356e8793d3306331533
  $tcVersion :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17742700663570508944##
                   9621300497526011443##
                   Defs.$trModule
                   Defs.$tcVersion1
                   0#
                   GHC.Types.krep$*) -}
dbef4b2d4722817ba748e090a3538bff
  $tcVersion1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Defs.$tcVersion2) -}
6f5234517f46fb8ed39565ee9933320f
  $tcVersion2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Version"#) -}
2922cc75e987f1ea44e2c8db8c6182e9
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Defs.$trModule3 Defs.$trModule1) -}
b3fd1e1a2e6df05902698c74f3f1e843
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Defs.$trModule2) -}
9dbbecc5b1a5fb7cdb820cb494e823c0
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Defs"#) -}
9296f1820b324ba5ed194e039d7c88fe
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Defs.$trModule4) -}
170a6ca2db3d203de8f1fca61a7979ab
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("main"#) -}
dd49189877e9c0906e61e8b8ea5723c5
  $w$c< ::
    GHC.Prim.Int#
    -> GHC.Base.String
    -> GHC.Prim.Int#
    -> GHC.Base.String
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs, Strictness: <S,U><L,1*U><S,U><L,1*U>,
     Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Base.String)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: GHC.Base.String) ->
                 case GHC.Prim.<# ww ww2 of lwild {
                   DEFAULT
                   -> case GHC.Prim.==# ww ww2 of lwild1 {
                        DEFAULT -> GHC.Types.False
                        1# -> GHC.Classes.$fOrd[]_$s$c<1 ww1 ww3 }
                   1# -> GHC.Types.True }) -}
aad6778a5b88b0e736ca0cf055f40f8a
  $w$c<= ::
    Defs.PName
    -> Defs.Version -> Defs.PName -> Defs.Version -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs, Strictness: <S,U><L,1*U><S,U><L,1*U>,
     Inline: [0],
     Unfolding: (\ (ww :: Defs.PName)
                   (ww1 :: Defs.Version)
                   (ww2 :: Defs.PName)
                   (ww3 :: Defs.Version) ->
                 case GHC.Classes.$fOrd[]_$s$ccompare1
                        ww `cast` (Defs.N:PName[0])
                        ww2 `cast` (Defs.N:PName[0]) of wild {
                   DEFAULT
                   -> case GHC.Base.eqString
                             ww `cast` (Defs.N:PName[0])
                             ww2 `cast` (Defs.N:PName[0]) of wild1 {
                        GHC.Types.False -> GHC.Types.False
                        GHC.Types.True
                        -> case GHC.Classes.$fOrd[]_$ccompare
                                  @ Defs.VNum
                                  Defs.$fOrdVNum
                                  ww1 `cast` (Defs.N:Version[0])
                                  ww3 `cast` (Defs.N:Version[0]) of wild2 {
                             DEFAULT -> GHC.Types.True GHC.Types.GT -> GHC.Types.False } }
                   GHC.Types.LT -> GHC.Types.True }) -}
569c7ebc2a282e7c7a912ef470cdf032
  $w$c<=1 ::
    GHC.Prim.Int#
    -> GHC.Base.String
    -> GHC.Prim.Int#
    -> GHC.Base.String
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs, Strictness: <S,U><L,1*U><S,U><L,1*U>,
     Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Base.String)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: GHC.Base.String) ->
                 case GHC.Prim.<# ww2 ww of lwild {
                   DEFAULT
                   -> case GHC.Prim.==# ww2 ww of lwild1 {
                        DEFAULT -> GHC.Types.True
                        1#
                        -> case GHC.Classes.$fOrd[]_$s$ccompare1 ww3 ww1 of wild {
                             DEFAULT -> GHC.Types.True GHC.Types.LT -> GHC.Types.False } }
                   1# -> GHC.Types.False }) -}
025adce32941f89109290e24d027733f
  $w$c== ::
    Defs.PName
    -> Defs.Version
    -> GHC.Base.String
    -> Defs.Constrs
    -> Defs.PName
    -> Defs.Version
    -> GHC.Base.String
    -> Defs.Constrs
    -> GHC.Types.Bool
  {- Arity: 8, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U><L,1*U><L,1*U><S,1*U><L,1*U><L,1*U><L,1*U>,
     Inline: [0],
     Unfolding: (\ (ww :: Defs.PName)
                   (ww1 :: Defs.Version)
                   (ww2 :: GHC.Base.String)
                   (ww3 :: Defs.Constrs)
                   (ww4 :: Defs.PName)
                   (ww5 :: Defs.Version)
                   (ww6 :: GHC.Base.String)
                   (ww7 :: Defs.Constrs) ->
                 case GHC.Base.eqString
                        ww `cast` (Defs.N:PName[0])
                        ww4 `cast` (Defs.N:PName[0]) of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> case GHC.Classes.$fEq[]_$c==
                             @ Defs.VNum
                             Defs.$fEqVNum
                             ww1 `cast` (Defs.N:Version[0])
                             ww5 `cast` (Defs.N:Version[0]) of wild1 {
                        GHC.Types.False -> GHC.Types.False
                        GHC.Types.True
                        -> case GHC.Base.eqString ww2 ww6 of wild2 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True
                             -> GHC.Classes.$fEq[]_$c==
                                  @ (Defs.PName, Defs.PConstr)
                                  Defs.$fEqPkg_$s$fEq(,)
                                  ww3
                                  ww7 } } }) -}
e2ce8ae2aae29b4241698488c916b30c
  $w$c==1 ::
    GHC.Prim.Int#
    -> GHC.Base.String
    -> GHC.Prim.Int#
    -> GHC.Base.String
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs, Strictness: <S,U><L,1*U><S,U><L,1*U>,
     Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Base.String)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: GHC.Base.String) ->
                 case GHC.Prim.==# ww ww2 of lwild {
                   DEFAULT -> GHC.Types.False 1# -> GHC.Base.eqString ww1 ww3 }) -}
3201a16fdc0f6151f05e46a65035ce41
  $w$c> ::
    Defs.PName
    -> Defs.Version
    -> GHC.Base.String
    -> Defs.Constrs
    -> Defs.PName
    -> Defs.Version
    -> GHC.Base.String
    -> Defs.Constrs
    -> GHC.Types.Bool
  {- Arity: 8, HasNoCafRefs,
     Strictness: <S,U><L,U><L,1*U><L,1*U><S,U><L,U><L,1*U><L,1*U>,
     Inline: [0],
     Unfolding: (\ (ww :: Defs.PName)
                   (ww1 :: Defs.Version)
                   (ww2 :: GHC.Base.String)
                   (ww3 :: Defs.Constrs)
                   (ww4 :: Defs.PName)
                   (ww5 :: Defs.Version)
                   (ww6 :: GHC.Base.String)
                   (ww7 :: Defs.Constrs) ->
                 case Defs.$w$c== ww ww1 ww2 ww3 ww4 ww5 ww6 ww7 of wild {
                   GHC.Types.False
                   -> case GHC.Classes.$fOrd[]_$s$ccompare1
                             ww `cast` (Defs.N:PName[0])
                             ww4 `cast` (Defs.N:PName[0]) of wild1 {
                        DEFAULT
                        -> case GHC.Base.eqString
                                  ww `cast` (Defs.N:PName[0])
                                  ww4 `cast` (Defs.N:PName[0]) of wild2 {
                             GHC.Types.False -> GHC.Types.True
                             GHC.Types.True
                             -> case GHC.Classes.$fOrd[]_$ccompare
                                       @ Defs.VNum
                                       Defs.$fOrdVNum
                                       ww1 `cast` (Defs.N:Version[0])
                                       ww5 `cast` (Defs.N:Version[0]) of wild3 {
                                  DEFAULT -> GHC.Types.False GHC.Types.GT -> GHC.Types.True } }
                        GHC.Types.LT -> GHC.Types.False }
                   GHC.Types.True -> GHC.Types.False }) -}
4d7e98e54eb175acee496528353137a9
  $w$c>= ::
    GHC.Prim.Int#
    -> GHC.Base.String
    -> GHC.Prim.Int#
    -> GHC.Base.String
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs, Strictness: <S,U><L,1*U><S,U><L,1*U>,
     Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Base.String)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: GHC.Base.String) ->
                 case GHC.Prim.<# ww ww2 of lwild {
                   DEFAULT
                   -> case GHC.Prim.==# ww ww2 of lwild1 {
                        DEFAULT -> GHC.Types.True
                        1#
                        -> case GHC.Classes.$fOrd[]_$s$ccompare1 ww1 ww3 of wild {
                             DEFAULT -> GHC.Types.True GHC.Types.LT -> GHC.Types.False } }
                   1# -> GHC.Types.False }) -}
33882017ae242c543355a2ffb32a9453
  $w$c>=1 ::
    Defs.PName
    -> Defs.Version
    -> GHC.Base.String
    -> Defs.Constrs
    -> Defs.PName
    -> Defs.Version
    -> GHC.Base.String
    -> Defs.Constrs
    -> GHC.Types.Bool
  {- Arity: 8, HasNoCafRefs,
     Strictness: <S,U><L,U><L,1*U><L,1*U><S,U><L,U><L,1*U><L,1*U>,
     Inline: [0],
     Unfolding: (\ (ww :: Defs.PName)
                   (ww1 :: Defs.Version)
                   (ww2 :: GHC.Base.String)
                   (ww3 :: Defs.Constrs)
                   (ww4 :: Defs.PName)
                   (ww5 :: Defs.Version)
                   (ww6 :: GHC.Base.String)
                   (ww7 :: Defs.Constrs) ->
                 case Defs.$w$c== ww ww1 ww2 ww3 ww4 ww5 ww6 ww7 of wild {
                   GHC.Types.False
                   -> case GHC.Classes.$fOrd[]_$s$ccompare1
                             ww `cast` (Defs.N:PName[0])
                             ww4 `cast` (Defs.N:PName[0]) of wild1 {
                        DEFAULT
                        -> case GHC.Base.eqString
                                  ww `cast` (Defs.N:PName[0])
                                  ww4 `cast` (Defs.N:PName[0]) of wild2 {
                             GHC.Types.False -> GHC.Types.True
                             GHC.Types.True
                             -> case GHC.Classes.$fOrd[]_$ccompare
                                       @ Defs.VNum
                                       Defs.$fOrdVNum
                                       ww1 `cast` (Defs.N:Version[0])
                                       ww5 `cast` (Defs.N:Version[0]) of wild3 {
                                  DEFAULT -> GHC.Types.False GHC.Types.GT -> GHC.Types.True } }
                        GHC.Types.LT -> GHC.Types.False }
                   GHC.Types.True -> GHC.Types.True }) -}
9642223e5fa2b8fd2ce2548fa53b3eba
  $w$ccompare ::
    GHC.Prim.Int#
    -> GHC.Base.String
    -> GHC.Prim.Int#
    -> GHC.Base.String
    -> GHC.Types.Ordering
  {- Arity: 4, HasNoCafRefs, Strictness: <S,U><L,1*U><S,U><L,1*U>,
     Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Base.String)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: GHC.Base.String) ->
                 case GHC.Prim.<# ww ww2 of lwild {
                   DEFAULT
                   -> case GHC.Prim.==# ww ww2 of lwild1 {
                        DEFAULT -> GHC.Types.GT
                        1# -> GHC.Classes.$fOrd[]_$s$ccompare1 ww1 ww3 }
                   1# -> GHC.Types.LT }) -}
386b2d95803e5ea88a4f754ae48d3d3c
  $w$ccompare1 ::
    Defs.PName
    -> Defs.Version
    -> GHC.Base.String
    -> Defs.Constrs
    -> Defs.PName
    -> Defs.Version
    -> GHC.Base.String
    -> Defs.Constrs
    -> GHC.Types.Ordering
  {- Arity: 8, HasNoCafRefs,
     Strictness: <S,U><L,U><L,1*U><L,1*U><S,U><L,U><L,1*U><L,1*U>,
     Inline: [0],
     Unfolding: (\ (ww :: Defs.PName)
                   (ww1 :: Defs.Version)
                   (ww2 :: GHC.Base.String)
                   (ww3 :: Defs.Constrs)
                   (ww4 :: Defs.PName)
                   (ww5 :: Defs.Version)
                   (ww6 :: GHC.Base.String)
                   (ww7 :: Defs.Constrs) ->
                 case Defs.$w$c== ww ww1 ww2 ww3 ww4 ww5 ww6 ww7 of wild {
                   GHC.Types.False
                   -> case GHC.Classes.$fOrd[]_$s$ccompare1
                             ww `cast` (Defs.N:PName[0])
                             ww4 `cast` (Defs.N:PName[0]) of wild1 {
                        DEFAULT
                        -> case GHC.Base.eqString
                                  ww `cast` (Defs.N:PName[0])
                                  ww4 `cast` (Defs.N:PName[0]) of wild2 {
                             GHC.Types.False -> GHC.Types.GT
                             GHC.Types.True
                             -> case GHC.Classes.$fOrd[]_$ccompare
                                       @ Defs.VNum
                                       Defs.$fOrdVNum
                                       ww1 `cast` (Defs.N:Version[0])
                                       ww5 `cast` (Defs.N:Version[0]) of wild3 {
                                  DEFAULT -> GHC.Types.LT GHC.Types.GT -> GHC.Types.GT } }
                        GHC.Types.LT -> GHC.Types.LT }
                   GHC.Types.True -> GHC.Types.EQ }) -}
f1583a426d94974bff3b76eacb5d8923
  $w$creadPrec ::
    GHC.Prim.Int#
    -> forall b.
       (Defs.Database -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <S,U><L,C(U)>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   @ b
                   (w :: Defs.Database -> Text.ParserCombinators.ReadP.P b) ->
                 case GHC.Prim.<=# ww 10# of lwild {
                   DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                   1#
                   -> let {
                        lvl118 :: Text.ParserCombinators.ReadP.P b
                        = let {
                            lvl119 :: Text.ParserCombinators.ReadP.P b
                            = (Defs.$fReadDatabase_$creadListPrec1
                                 `cast`
                               (Text.ParserCombinators.ReadPrec.N:ReadPrec[0] <[Defs.Pkg]>_R)
                                 Defs.$fReadDatabase5)
                                `cast`
                              (Text.ParserCombinators.ReadP.N:ReadP[0] <[Defs.Pkg]>_R)
                                @ b
                                (\ (a1 :: [Defs.Pkg]) -> w a1 `cast` (Sym (Defs.N:Database[0])))
                          } in
                          Text.Read.Lex.expect2
                            @ b
                            (\ (a3 :: Text.Read.Lex.Lexeme) ->
                             case a3 of wild {
                               DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                               Text.Read.Lex.Ident a1
                               -> case GHC.Base.eqString a1 Defs.$fReadDatabase3 of wild1 {
                                    GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                                    GHC.Types.True -> lvl119 } })
                      } in
                      let {
                        k :: () -> Text.ParserCombinators.ReadP.P b
                          {- Arity: 1, Strictness: <L,A>,
                             Unfolding: InlineRule (1, True, True) (\ (a3 :: ()) -> lvl118) -}
                        = \ (a3 :: ()) -> lvl118
                      } in
                      Text.ParserCombinators.ReadP.Look
                        @ b
                        (\ (a :: GHC.Base.String) ->
                         Text.ParserCombinators.ReadP.skipSpaces2 a @ b k) }) -}
67c0e1532f060e36c08615a4e1246c25
  $w$creadPrec1 ::
    GHC.Prim.Int#
    -> forall b.
       (Defs.Pkg -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <S,U><L,C(U)>, Inline: [0] -}
f57ad031236d47377cee1c770af63619
  $w$creadPrec2 ::
    GHC.Prim.Int#
    -> forall b.
       (Defs.PName -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <S,U><L,C(U)>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   @ b
                   (w :: Defs.PName -> Text.ParserCombinators.ReadP.P b) ->
                 case GHC.Prim.<=# ww 10# of lwild {
                   DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                   1#
                   -> let {
                        lvl118 :: Text.ParserCombinators.ReadP.P b
                        = let {
                            lvl119 :: Text.ParserCombinators.ReadP.P b
                            = GHC.Read.$fRead()6
                                @ GHC.Base.String
                                GHC.Read.$fReadChar2
                                  `cast`
                                (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                          <GHC.Base.String>_R))
                                Defs.$fReadDatabase5
                                @ b
                                (\ (a1 :: GHC.Base.String) -> w a1 `cast` (Sym (Defs.N:PName[0])))
                          } in
                          Text.Read.Lex.expect2
                            @ b
                            (\ (a3 :: Text.Read.Lex.Lexeme) ->
                             case a3 of wild {
                               DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                               Text.Read.Lex.Ident a1
                               -> case GHC.Base.eqString a1 Defs.$fReadPName3 of wild1 {
                                    GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                                    GHC.Types.True -> lvl119 } })
                      } in
                      let {
                        k :: () -> Text.ParserCombinators.ReadP.P b
                          {- Arity: 1, Strictness: <L,A>,
                             Unfolding: InlineRule (1, True, True) (\ (a3 :: ()) -> lvl118) -}
                        = \ (a3 :: ()) -> lvl118
                      } in
                      Text.ParserCombinators.ReadP.Look
                        @ b
                        (\ (a :: GHC.Base.String) ->
                         Text.ParserCombinators.ReadP.skipSpaces2 a @ b k) }) -}
357a140a7e8d240bdb378f37a89369a9
  $w$creadPrec3 ::
    GHC.Prim.Int#
    -> forall b.
       (Defs.VNum -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <S,U><L,C(U)>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   @ b
                   (w :: Defs.VNum -> Text.ParserCombinators.ReadP.P b) ->
                 case GHC.Prim.<=# ww 10# of lwild {
                   DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                   1#
                   -> let {
                        lvl118 :: Text.ParserCombinators.ReadP.P b
                        = let {
                            lvl119 :: Text.ParserCombinators.ReadP.P b
                            = GHC.Read.$fReadInt_$sreadNumber
                                GHC.Read.$fReadInt2
                                Defs.$fReadDatabase5
                                @ b
                                (\ (a1 :: GHC.Types.Int) ->
                                 GHC.Read.$fRead()6
                                   @ GHC.Base.String
                                   GHC.Read.$fReadChar2
                                     `cast`
                                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                             <GHC.Base.String>_R))
                                   Defs.$fReadDatabase5
                                   @ b
                                   (\ (a2 :: GHC.Base.String) -> w (Defs.VN a1 a2)))
                          } in
                          Text.Read.Lex.expect2
                            @ b
                            (\ (a3 :: Text.Read.Lex.Lexeme) ->
                             case a3 of wild {
                               DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                               Text.Read.Lex.Ident a1
                               -> case GHC.Base.eqString a1 Defs.$fReadVNum3 of wild1 {
                                    GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                                    GHC.Types.True -> lvl119 } })
                      } in
                      let {
                        k :: () -> Text.ParserCombinators.ReadP.P b
                          {- Arity: 1, Strictness: <L,A>,
                             Unfolding: InlineRule (1, True, True) (\ (a3 :: ()) -> lvl118) -}
                        = \ (a3 :: ()) -> lvl118
                      } in
                      Text.ParserCombinators.ReadP.Look
                        @ b
                        (\ (a :: GHC.Base.String) ->
                         Text.ParserCombinators.ReadP.skipSpaces2 a @ b k) }) -}
dac81863e92b466ccdd232182575e76a
  $w$creadPrec4 ::
    GHC.Prim.Int#
    -> forall b.
       (Defs.Version -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <S,U><L,C(U)>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   @ b
                   (w :: Defs.Version -> Text.ParserCombinators.ReadP.P b) ->
                 case GHC.Prim.<=# ww 10# of lwild {
                   DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                   1#
                   -> let {
                        lvl118 :: Text.ParserCombinators.ReadP.P b
                        = let {
                            lvl119 :: Text.ParserCombinators.ReadP.P b
                            = (Defs.$fReadVNum_$creadListPrec
                                 `cast`
                               (Text.ParserCombinators.ReadPrec.N:ReadPrec[0] <[Defs.VNum]>_R)
                                 Defs.$fReadDatabase5)
                                `cast`
                              (Text.ParserCombinators.ReadP.N:ReadP[0] <[Defs.VNum]>_R)
                                @ b
                                (\ (a1 :: [Defs.VNum]) -> w a1 `cast` (Sym (Defs.N:Version[0])))
                          } in
                          Text.Read.Lex.expect2
                            @ b
                            (\ (a3 :: Text.Read.Lex.Lexeme) ->
                             case a3 of wild {
                               DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                               Text.Read.Lex.Ident a1
                               -> case GHC.Base.eqString a1 Defs.$fReadVersion3 of wild1 {
                                    GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                                    GHC.Types.True -> lvl119 } })
                      } in
                      let {
                        k :: () -> Text.ParserCombinators.ReadP.P b
                          {- Arity: 1, Strictness: <L,A>,
                             Unfolding: InlineRule (1, True, True) (\ (a3 :: ()) -> lvl118) -}
                        = \ (a3 :: ()) -> lvl118
                      } in
                      Text.ParserCombinators.ReadP.Look
                        @ b
                        (\ (a :: GHC.Base.String) ->
                         Text.ParserCombinators.ReadP.skipSpaces2 a @ b k) }) -}
6d9f44d41e53ea0c053f6fc34bde020b
  $w$cshow :: GHC.Types.Int -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U(U)><L,1*U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Types.Int) (ww1 :: GHC.Base.String) ->
                 GHC.CString.unpackAppendCString#
                   Defs.$fShowVNum2
                   (case ww of ww2 { GHC.Types.I# ww3 ->
                    case GHC.Show.$wshowSignedInt
                           11#
                           ww3
                           (GHC.Types.:
                              @ GHC.Types.Char
                              GHC.Show.showSpace1
                              (GHC.Types.:
                                 @ GHC.Types.Char
                                 GHC.Show.$fShow(,)3
                                 (GHC.Show.showLitString
                                    ww1
                                    Defs.$fShowVNum3))) of ww4 { (#,#) ww5 ww6 ->
                    GHC.Types.: @ GHC.Types.Char ww5 ww6 } })) -}
f57ad031236d47377cee1c770af63619
  $w$cshowsPrec ::
    GHC.Prim.Int# -> Defs.PName -> GHC.Base.String -> GHC.Base.String
  {- Arity: 3, Strictness: <S,U><L,1*U><L,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (w :: Defs.PName)
                   (w1 :: GHC.Base.String) ->
                 case GHC.Prim.>=# ww 11# of lwild {
                   DEFAULT
                   -> GHC.CString.unpackAppendCString#
                        Defs.$fShowPName2
                        (GHC.Types.:
                           @ GHC.Types.Char
                           GHC.Show.$fShow(,)3
                           (GHC.Show.showLitString
                              w `cast` (Defs.N:PName[0])
                              (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)3 w1)))
                   1#
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.$fShow(,)4
                        (GHC.CString.unpackAppendCString#
                           Defs.$fShowPName2
                           (GHC.Types.:
                              @ GHC.Types.Char
                              GHC.Show.$fShow(,)3
                              (GHC.Show.showLitString
                                 w `cast` (Defs.N:PName[0])
                                 (GHC.Types.:
                                    @ GHC.Types.Char
                                    GHC.Show.$fShow(,)3
                                    (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 w1))))) }) -}
4eb69d1c841bdd0a63e82f085a2a9e42
  $w$cshowsPrec1 ::
    GHC.Prim.Int#
    -> Defs.PName
    -> Defs.Version
    -> GHC.Base.String
    -> Defs.Constrs
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 6, Strictness: <S,U><L,1*U><L,1*U><L,1*U><L,1*U><L,U>,
     Inline: [0] -}
72f6052e90b9d9c823be840f57e5af36
  $w$cshowsPrec2 ::
    GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Base.String
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 4, Strictness: <S,U><L,1*U(U)><L,1*U><L,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Types.Int)
                   (ww2 :: GHC.Base.String)
                   (w :: GHC.Base.String) ->
                 let {
                   p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,U> -}
                   = \ (x :: GHC.Base.String)[OneShot] ->
                     GHC.CString.unpackAppendCString#
                       Defs.$fShowVNum2
                       (case ww1 of ww3 { GHC.Types.I# ww4 ->
                        case GHC.Show.$wshowSignedInt
                               11#
                               ww4
                               (GHC.Types.:
                                  @ GHC.Types.Char
                                  GHC.Show.showSpace1
                                  (GHC.Types.:
                                     @ GHC.Types.Char
                                     GHC.Show.$fShow(,)3
                                     (GHC.Show.showLitString
                                        ww2
                                        (GHC.Types.:
                                           @ GHC.Types.Char
                                           GHC.Show.$fShow(,)3
                                           x)))) of ww5 { (#,#) ww6 ww7 ->
                        GHC.Types.: @ GHC.Types.Char ww6 ww7 } })
                 } in
                 case GHC.Prim.>=# ww 11# of lwild {
                   DEFAULT -> p w
                   1#
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.$fShow(,)4
                        (p (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 w)) }) -}
dac81863e92b466ccdd232182575e76a
  $w$cshowsPrec3 ::
    GHC.Prim.Int# -> Defs.Version -> GHC.Base.String -> GHC.Base.String
  {- Arity: 3, Strictness: <S,U><L,1*U><L,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (w :: Defs.Version)
                   (w1 :: GHC.Base.String) ->
                 let {
                   p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,U> -}
                   = \ (x :: GHC.Base.String)[OneShot] ->
                     GHC.CString.unpackAppendCString#
                       Defs.$fShowVersion2
                       (case w `cast` (Defs.N:Version[0]) of wild {
                          [] -> GHC.CString.unpackAppendCString# GHC.Show.showList__4 x
                          : x1 xs
                          -> GHC.Types.:
                               @ GHC.Types.Char
                               GHC.Show.showList__3
                               (case x1 of wild1 { Defs.VN b1 b2 ->
                                GHC.CString.unpackAppendCString#
                                  Defs.$fShowVNum2
                                  (case b1 of ww2 { GHC.Types.I# ww3 ->
                                   case GHC.Show.$wshowSignedInt
                                          11#
                                          ww3
                                          (GHC.Types.:
                                             @ GHC.Types.Char
                                             GHC.Show.showSpace1
                                             (GHC.Types.:
                                                @ GHC.Types.Char
                                                GHC.Show.$fShow(,)3
                                                (GHC.Show.showLitString
                                                   b2
                                                   (GHC.Types.:
                                                      @ GHC.Types.Char
                                                      GHC.Show.$fShow(,)3
                                                      (let {
                                                         lvl30 :: [GHC.Types.Char]
                                                         = GHC.Types.:
                                                             @ GHC.Types.Char
                                                             GHC.Show.showList__2
                                                             x
                                                       } in
                                                       letrec {
                                                         showl :: [Defs.VNum] -> GHC.Base.String
                                                           {- Arity: 1, Strictness: <S,1*U> -}
                                                         = \ (ds3 :: [Defs.VNum]) ->
                                                           case ds3 of wild2 {
                                                             [] -> lvl30
                                                             : y ys
                                                             -> GHC.Types.:
                                                                  @ GHC.Types.Char
                                                                  GHC.Show.showList__1
                                                                  (case y of wild3 { Defs.VN b4 b5 ->
                                                                   GHC.CString.unpackAppendCString#
                                                                     Defs.$fShowVNum2
                                                                     (case b4 of ww1 { GHC.Types.I# ww5 ->
                                                                      case GHC.Show.$wshowSignedInt
                                                                             11#
                                                                             ww5
                                                                             (GHC.Types.:
                                                                                @ GHC.Types.Char
                                                                                GHC.Show.showSpace1
                                                                                (GHC.Types.:
                                                                                   @ GHC.Types.Char
                                                                                   GHC.Show.$fShow(,)3
                                                                                   (GHC.Show.showLitString
                                                                                      b5
                                                                                      (GHC.Types.:
                                                                                         @ GHC.Types.Char
                                                                                         GHC.Show.$fShow(,)3
                                                                                         (showl
                                                                                            ys))))) of ww4 { (#,#) ww6 ww7 ->
                                                                      GHC.Types.:
                                                                        @ GHC.Types.Char
                                                                        ww6
                                                                        ww7 } }) }) }
                                                       } in
                                                       showl xs))))) of ww4 { (#,#) ww5 ww6 ->
                                   GHC.Types.: @ GHC.Types.Char ww5 ww6 } }) }) })
                 } in
                 case GHC.Prim.>=# ww 11# of lwild {
                   DEFAULT -> p w1
                   1#
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.$fShow(,)4
                        (p (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 w1)) }) -}
d748efbcfd6e9eb389ceceebc299836d
  $wprettyConstr ::
    Defs.PName
    -> GHC.Types.Bool
    -> Defs.Version
    -> Defs.Version
    -> GHC.Base.String
  {- Arity: 4, Strictness: <L,U><S,U><L,U><L,1*U>, Inline: [0],
     Unfolding: (\ (ww :: Defs.PName)
                   (ww1 :: GHC.Types.Bool)
                   (ww2 :: Defs.Version)
                   (ww3 :: Defs.Version) ->
                 let {
                   arg :: [GHC.Types.Char]
                   = GHC.Base.++
                       @ GHC.Types.Char
                       ww `cast` (Defs.N:PName[0])
                       (let {
                          arg1 :: [GHC.Types.Char]
                          = GHC.Base.++
                              @ GHC.Types.Char
                              (Defs.prettyVer ww2)
                              (GHC.CString.unpackAppendCString#
                                 Defs.prettyPkg9
                                 (let {
                                    arg2 :: [GHC.Types.Char]
                                    = GHC.Base.++
                                        @ GHC.Types.Char
                                        ww `cast` (Defs.N:PName[0])
                                        (case ww1 of wild {
                                           GHC.Types.False
                                           -> GHC.Base.++
                                                @ GHC.Types.Char
                                                Defs.prettyConstr8
                                                (GHC.Base.++
                                                   @ GHC.Types.Char
                                                   (Defs.prettyVer ww3)
                                                   Defs.prettyConstr7)
                                           GHC.Types.True
                                           -> GHC.Base.++
                                                @ GHC.Types.Char
                                                Defs.prettyConstr5
                                                (GHC.Base.++
                                                   @ GHC.Types.Char
                                                   (Defs.prettyVer ww3)
                                                   Defs.prettyConstr7) })
                                  } in
                                  case ww1 of wild {
                                    GHC.Types.False
                                    -> GHC.Base.++ @ GHC.Types.Char Defs.prettyConstr3 arg2
                                    GHC.Types.True
                                    -> GHC.Base.++ @ GHC.Types.Char Defs.prettyConstr1 arg2 }))
                        } in
                        case ww1 of wild {
                          GHC.Types.False
                          -> GHC.Base.++ @ GHC.Types.Char Defs.prettyConstr5 arg1
                          GHC.Types.True
                          -> case GHC.Classes.$fOrd[]_$ccompare
                                    @ Defs.VNum
                                    Defs.$fOrdVNum
                                    ww2 `cast` (Defs.N:Version[0])
                                    Defs.minV1 of wild1 {
                               DEFAULT -> GHC.Base.++ @ GHC.Types.Char Defs.prettyConstr5 arg1
                               GHC.Types.GT
                               -> GHC.Base.++ @ GHC.Types.Char Defs.prettyConstr8 arg1 } })
                 } in
                 case ww1 of wild {
                   GHC.Types.False
                   -> GHC.Base.++ @ GHC.Types.Char Defs.prettyConstr3 arg
                   GHC.Types.True
                   -> GHC.Base.++ @ GHC.Types.Char Defs.prettyConstr1 arg }) -}
cbb1aa32e2be9d78bf08047877f45a4b
  $wprettyPkg ::
    Defs.PName
    -> Defs.Version
    -> GHC.Base.String
    -> Defs.Constrs
    -> GHC.Base.String
  {- Arity: 4, Strictness: <L,1*U><L,U><L,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ (ww :: Defs.PName)
                   (ww1 :: Defs.Version)
                   (ww2 :: GHC.Base.String)
                   (ww3 :: Defs.Constrs) ->
                 GHC.CString.unpackAppendCString#
                   Defs.prettyPkg10
                   (GHC.Base.++
                      @ GHC.Types.Char
                      ww `cast` (Defs.N:PName[0])
                      (GHC.CString.unpackAppendCString#
                         Defs.prettyPkg9
                         (let {
                            arg :: [GHC.Types.Char]
                            = case ww2 of wild {
                                [] -> Defs.prettyPkg_go ww3
                                : ds3 ds4
                                -> GHC.CString.unpackAppendCString#
                                     Defs.prettyPkg8
                                     (let {
                                        z :: [GHC.Types.Char]
                                        = GHC.CString.unpackAppendCString#
                                            Defs.prettyPkg7
                                            (Defs.prettyPkg_go ww3)
                                      } in
                                      letrec {
                                        go :: [GHC.Types.Char] -> [GHC.Types.Char]
                                          {- Arity: 1, Strictness: <S,1*U> -}
                                        = \ (ds5 :: [GHC.Types.Char]) ->
                                          case ds5 of wild1 {
                                            [] -> z
                                            : y ys
                                            -> case y of wild2 { GHC.Types.C# ds6 ->
                                               case ds6 of ds7 {
                                                 DEFAULT
                                                 -> GHC.Types.: @ GHC.Types.Char wild2 (go ys)
                                                 '"'#
                                                 -> GHC.Base.++
                                                      @ GHC.Types.Char
                                                      Defs.prettyPkg5
                                                      (go ys) } } }
                                      } in
                                      go wild) }
                          } in
                          case GHC.Classes.$fEq[]_$c==
                                 @ Defs.VNum
                                 Defs.$fEqVNum
                                 ww1 `cast` (Defs.N:Version[0])
                                 Defs.prettyPkg2 of wild {
                            GHC.Types.False
                            -> GHC.CString.unpackAppendCString#
                                 Defs.prettyPkg1
                                 (GHC.Base.++
                                    @ GHC.Types.Char
                                    (Defs.prettyVer ww1)
                                    (GHC.CString.unpackAppendCString# Defs.prettyPkg9 arg))
                            GHC.Types.True -> arg })))) -}
9a7c3453c9d2e31f7e4903b75f608e72
  type Constrs = [(Defs.PName, Defs.PConstr)]
f1583a426d94974bff3b76eacb5d8923
  newtype Database = DB [Defs.Pkg]
832e4b49f39f830e3fa7575301a38b17
  type ErrMsg = GHC.Base.String
78cf45f9e0d6beb5a2f0eabf20ae0f3f
  type PConstr = (GHC.Types.Bool, Defs.Version, Defs.Version)
f57ad031236d47377cee1c770af63619
  newtype PName = P GHC.Base.String
67c0e1532f060e36c08615a4e1246c25
  data Pkg
    = Pkg {name :: Defs.PName,
           ver :: Defs.Version,
           desc :: GHC.Base.String,
           deps :: Defs.Constrs}
ecbba19d4c7e407535cb2f8a0395ec83
  type Sol = [(Defs.PName, Defs.Version)]
357a140a7e8d240bdb378f37a89369a9
  data VNum = VN GHC.Types.Int GHC.Base.String
dac81863e92b466ccdd232182575e76a
  newtype Version = V [Defs.VNum]
67c0e1532f060e36c08615a4e1246c25
  deps :: Defs.Pkg -> Defs.Constrs
  RecSel Left Defs.Pkg
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLLS),1*U(A,A,A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds3 :: Defs.Pkg) ->
                 case ds3 of wild { Defs.Pkg ds4 ds5 ds6 ds7 -> ds7 }) -}
67c0e1532f060e36c08615a4e1246c25
  desc :: Defs.Pkg -> GHC.Base.String
  RecSel Left Defs.Pkg
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLSL),1*U(A,A,1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds3 :: Defs.Pkg) ->
                 case ds3 of wild { Defs.Pkg ds4 ds5 ds6 ds7 -> ds6 }) -}
d5f2cbf233e4375ee4d69ae54cb88f02
  maxV :: Defs.Version
  {- Strictness: m2,
     Unfolding: InlineRule (0, True, True)
                Defs.maxV1 `cast` (Sym (Defs.N:Version[0])) -}
a1b0c8b3cb2f1dcc3f923fde788bb426
  maxV1 :: [Defs.VNum]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Defs.VNum
                   Defs.maxV2
                   (GHC.Types.[] @ Defs.VNum)) -}
d0d058625f243a6f236064a948d7e653
  maxV2 :: Defs.VNum
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (Defs.VN Defs.maxV3 (GHC.Types.[] @ GHC.Types.Char)) -}
76180b482240365631030fb4517d9c97
  maxV3 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.I# 1000000#) -}
0eb6d2a314d21c7ed6107406103873f1
  minV :: Defs.Version
  {- Strictness: m2,
     Unfolding: InlineRule (0, True, True)
                Defs.minV1 `cast` (Sym (Defs.N:Version[0])) -}
27590a4c18275a8fcb0d09a688e32aef
  minV1 :: [Defs.VNum]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Defs.VNum
                   Defs.minV2
                   (GHC.Types.[] @ Defs.VNum)) -}
6ceb2dcb5767a05b60c031d8950b604f
  minV2 :: Defs.VNum
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (Defs.VN
                   Defs.$fShowPkg2
                   (GHC.Types.[] @ GHC.Types.Char)) -}
67c0e1532f060e36c08615a4e1246c25
  name :: Defs.Pkg -> Defs.PName
  RecSel Left Defs.Pkg
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SLLL),1*U(1*U,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds3 :: Defs.Pkg) ->
                 case ds3 of wild { Defs.Pkg ds4 ds5 ds6 ds7 -> ds4 }) -}
03f621d6b0288065d76627fcef0c592a
  prettyConstr :: (Defs.PName, Defs.PConstr) -> GHC.Base.String
  {- Arity: 1, Strictness: <S(LS(SLL)),1*U(U,1*U(U,U,1*U))>,
     Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: (Defs.PName, Defs.PConstr)) ->
                 case w of ww { (,) ww1 ww2 ->
                 case ww2 of ww3 { (,,) ww4 ww5 ww6 ->
                 Defs.$wprettyConstr ww1 ww4 ww5 ww6 } }) -}
f8b2bc74f963162d6e8ffee6b2a6a974
  prettyConstr1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Defs.prettyConstr2) -}
e3233b839761d3fc2a2fccf6d0b4349b
  prettyConstr2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("  requires "#) -}
f0555db70b9a75d9239dde868bbf8540
  prettyConstr3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Defs.prettyConstr4) -}
8de5214364452e6e4de3ae5e77fccf20
  prettyConstr4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("  conflicts "#) -}
69648969bd08a98c78eea6ba0d4668be
  prettyConstr5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Defs.prettyConstr6) -}
768ff215d95389a3cd2e21006b453a3f
  prettyConstr6 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (" < "#) -}
4dfd32105cb998ef550c8c0e4106336b
  prettyConstr7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Defs.prettyPkg9) -}
aef4d819508d4259bfd185b4c3d0d870
  prettyConstr8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Defs.prettyConstr9) -}
a44fb4990756a95f2c10bb2c7d969b4c
  prettyConstr9 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (" >= "#) -}
07b45283f6ed391e5729ad887c0f8029
  prettyConstrs :: Defs.Constrs -> GHC.Base.String
  {- Arity: 1,
     Unfolding: (Defs.$sconcatMap
                   @ (Defs.PName, Defs.PConstr)
                   @ GHC.Types.Char
                   Defs.prettyConstr) -}
6f11994a0c4cc685979e5886318c8e1f
  prettyPName :: Defs.PName -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Defs.prettyPName1 `cast` (<Defs.PName>_R ->_R Defs.N:PName[0]) -}
06b7559da0d74ef9a20adf09fcec0bc9
  prettyPName1 :: Defs.PName -> Defs.PName
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True)
                (\ (ds3 :: Defs.PName) -> ds3) -}
52eee3fab7945dd11ea690ded1d94511
  prettyPkg :: Defs.Pkg -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U,U,1*U,1*U)>, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Defs.Pkg) ->
                 case w of ww { Defs.Pkg ww1 ww2 ww3 ww4 ->
                 Defs.$wprettyPkg ww1 ww2 ww3 ww4 }) -}
477078b38f843ccdadb6b08fd80eef16
  prettyPkg1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("  version "#) -}
c9f8599dc18f91594f39e648a0850941
  prettyPkg10 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("package {\n\
                 \  name "#) -}
9b0750d736e79070df29701877e05f8d
  prettyPkg2 :: [Defs.VNum]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Defs.VNum
                   Defs.prettyPkg3
                   (GHC.Types.[] @ Defs.VNum)) -}
9bebcf9460b9478d920cbd5506688369
  prettyPkg3 :: Defs.VNum
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (Defs.VN
                   Defs.prettyPkg4
                   (GHC.Types.[] @ GHC.Types.Char)) -}
03df3c9496f5535cde4811e06f4008a0
  prettyPkg4 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 1#) -}
8ddf37128bf15584d4b6207d771a4ae8
  prettyPkg5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Defs.prettyPkg6) -}
752ae1ccdab8eca195adfa06d7c153f2
  prettyPkg6 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("\"\""#) -}
7061cd29ab7d0f39ed2a8975cc4263a1
  prettyPkg7 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("\";\n"#) -}
1aa28c7e423e23383cd792a22f21492b
  prettyPkg8 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("  description \""#) -}
6ced19f21639717685e445e2ee35257f
  prettyPkg9 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (";\n"#) -}
6ba1a4bba99db10e5e2a3672886b7b9e
  prettyPkg_go :: [(Defs.PName, Defs.PConstr)] -> [GHC.Types.Char]
  {- Arity: 1, Strictness: <S,1*U> -}
9250e19ded23ca417ddbbf2f04b8dd05
  prettyPkgs :: [Defs.Pkg] -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (x :: [Defs.Pkg]) ->
                 case GHC.Base.map
                        @ Defs.Pkg
                        @ [GHC.Types.Char]
                        Defs.prettyPkg
                        x of wild {
                   [] -> GHC.Types.[] @ GHC.Types.Char
                   : x1 xs1
                   -> Data.OldList.intercalate_$spoly_go
                        @ GHC.Types.Char
                        x1
                        (Data.OldList.prependToAll
                           @ [GHC.Types.Char]
                           Defs.prettyPkgs_xs
                           xs1) }) -}
01ef74484e7d9c7b2eb440003c338927
  prettyPkgs1 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("\n\
                 \\n"#) -}
8ce6e517362c9e51a60b089dc44b370e
  prettyPkgs_xs :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Defs.prettyPkgs1) -}
e72cbc1cf0d69f69e70b8f59f6efc8e1
  prettyVNum :: Defs.VNum -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(S(S)L),1*U(1*U(U),1*U)>m2, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Defs.VNum) ->
                 case w of ww { Defs.VN ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case GHC.Show.$wshowSignedInt
                        0#
                        ww4
                        (GHC.Types.[] @ GHC.Types.Char) of ww5 { (#,#) ww6 ww7 ->
                 GHC.Base.++_$s++ @ GHC.Types.Char ww2 ww6 ww7 } } }) -}
c042b0d1047728bd92526858a4f10f8b
  prettyVer :: Defs.Version -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds3 :: Defs.Version) ->
                 case GHC.Base.map
                        @ Defs.VNum
                        @ [GHC.Types.Char]
                        Defs.prettyVNum
                        ds3 `cast` (Defs.N:Version[0]) of wild {
                   [] -> GHC.Types.[] @ GHC.Types.Char
                   : x xs1
                   -> Data.OldList.intercalate_$spoly_go
                        @ GHC.Types.Char
                        x
                        (Data.OldList.prependToAll
                           @ [GHC.Types.Char]
                           Defs.prettyVer1
                           xs1) }) -}
902ea104ff651541a407bfbb692b7ea9
  prettyVer1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Defs.prettyVer2) -}
32a2ca527aceecd5cc28e88e2212979c
  prettyVer2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("."#) -}
3d3bc43a34c6afc23fb239002cc8357f
  stdV :: Defs.Version
  {- Strictness: m2,
     Unfolding: InlineRule (0, True, True)
                Defs.prettyPkg2 `cast` (Sym (Defs.N:Version[0])) -}
67c0e1532f060e36c08615a4e1246c25
  ver :: Defs.Pkg -> Defs.Version
  RecSel Left Defs.Pkg
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LSLL),1*U(A,1*U,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds3 :: Defs.Pkg) ->
                 case ds3 of wild { Defs.Pkg ds4 ds5 ds6 ds7 -> ds5 }) -}
instance [safe] GHC.Classes.Eq [Defs.Database] = Defs.$fEqDatabase
instance [safe] GHC.Classes.Eq [Defs.PName] = Defs.$fEqPName
instance [safe] GHC.Classes.Eq [Defs.Pkg] = Defs.$fEqPkg
instance [safe] GHC.Classes.Eq [Defs.VNum] = Defs.$fEqVNum
instance [safe] GHC.Classes.Eq [Defs.Version] = Defs.$fEqVersion
instance [safe] GHC.Classes.Ord [Defs.PName] = Defs.$fOrdPName
instance [safe] GHC.Classes.Ord [Defs.Pkg] = Defs.$fOrdPkg
instance [safe] GHC.Classes.Ord [Defs.VNum] = Defs.$fOrdVNum
instance [safe] GHC.Classes.Ord [Defs.Version] = Defs.$fOrdVersion
instance [safe] GHC.Read.Read [Defs.Database] = Defs.$fReadDatabase
instance [safe] GHC.Read.Read [Defs.PName] = Defs.$fReadPName
instance [safe] GHC.Read.Read [Defs.Pkg] = Defs.$fReadPkg
instance [safe] GHC.Read.Read [Defs.VNum] = Defs.$fReadVNum
instance [safe] GHC.Read.Read [Defs.Version] = Defs.$fReadVersion
instance [safe] GHC.Show.Show [Defs.Database] = Defs.$fShowDatabase
instance [safe] GHC.Show.Show [Defs.PName] = Defs.$fShowPName
instance [safe] GHC.Show.Show [Defs.Pkg] = Defs.$fShowPkg
instance [safe] GHC.Show.Show [Defs.VNum] = Defs.$fShowVNum
instance [safe] GHC.Show.Show [Defs.Version] = Defs.$fShowVersion
"SPEC/Defs $fEq(,) @ PName @ (Bool, Version, Version)" forall (v1 :: GHC.Classes.Eq
                                                                       (GHC.Types.Bool,
                                                                        Defs.Version, Defs.Version))
                                                              (v :: GHC.Classes.Eq Defs.PName)
  GHC.Classes.$fEq(,) @ Defs.PName
                      @ (GHC.Types.Bool, Defs.Version, Defs.Version)
                      v
                      v1
  = Defs.$fEqPkg_$s$fEq(,)
"SPEC/Defs $fEq(,)_$c/= @ PName @ (Bool, Version, Version)" forall ($dEq1 :: GHC.Classes.Eq
                                                                               (GHC.Types.Bool,
                                                                                Defs.Version,
                                                                                Defs.Version))
                                                                   ($dEq :: GHC.Classes.Eq
                                                                              Defs.PName)
  GHC.Classes.$fEq(,)_$c/= @ Defs.PName
                           @ (GHC.Types.Bool, Defs.Version, Defs.Version)
                           $dEq
                           $dEq1
  = Defs.$fEqPkg_$s$fEq(,)_$c/=
"SPEC/Defs $fEq(,,) @ Bool @ Version @ Version" forall (v2 :: GHC.Classes.Eq
                                                                Defs.Version)
                                                       (v1 :: GHC.Classes.Eq Defs.Version)
                                                       (v :: GHC.Classes.Eq GHC.Types.Bool)
  GHC.Classes.$fEq(,,) @ GHC.Types.Bool
                       @ Defs.Version
                       @ Defs.Version
                       v
                       v1
                       v2
  = Defs.$fEqPkg_$s$fEq(,,)
"SPEC/Defs $fEq(,,)_$c/= @ Bool @ Version @ Version" forall ($dEq2 :: GHC.Classes.Eq
                                                                        Defs.Version)
                                                            ($dEq1 :: GHC.Classes.Eq Defs.Version)
                                                            ($dEq :: GHC.Classes.Eq GHC.Types.Bool)
  GHC.Classes.$fEq(,,)_$c/= @ GHC.Types.Bool
                            @ Defs.Version
                            @ Defs.Version
                            $dEq
                            $dEq1
                            $dEq2
  = Defs.$fEqPkg_$s$fEq(,,)_$c/=
"SPEC/Defs $fEq[]_$c/= @ Pkg" forall ($dEq :: GHC.Classes.Eq
                                                Defs.Pkg)
  GHC.Classes.$fEq[]_$c/= @ Defs.Pkg $dEq
  = Defs.$fEqDatabase_$s$fEq[]_$c/=
"SPEC/Defs $fEq[]_$c/= @ VNum" forall ($dEq :: GHC.Classes.Eq
                                                 Defs.VNum)
  GHC.Classes.$fEq[]_$c/= @ Defs.VNum $dEq
  = Defs.$fEqVersion_$s$fEq[]_$c/=
"SPEC/Defs $fRead(,,) @ Bool @ Version @ Version" forall (v2 :: GHC.Read.Read
                                                                  Defs.Version)
                                                         (v1 :: GHC.Read.Read Defs.Version)
                                                         (v :: GHC.Read.Read GHC.Types.Bool)
  GHC.Read.$fRead(,,) @ GHC.Types.Bool
                      @ Defs.Version
                      @ Defs.Version
                      v
                      v1
                      v2
  = Defs.$s$fRead(,,)
"SPEC/Defs $fRead(,,)_$creadListPrec @ Bool @ Version @ Version" forall ($dRead2 :: GHC.Read.Read
                                                                                      Defs.Version)
                                                                        ($dRead1 :: GHC.Read.Read
                                                                                      Defs.Version)
                                                                        ($dRead :: GHC.Read.Read
                                                                                     GHC.Types.Bool)
  GHC.Read.$fRead(,,)_$creadListPrec @ GHC.Types.Bool
                                     @ Defs.Version
                                     @ Defs.Version
                                     $dRead
                                     $dRead1
                                     $dRead2
  = Defs.$s$fRead(,,)_$creadListPrec
"SPEC/Defs $fRead(,,)_$creadsPrec @ Bool @ Version @ Version" forall ($dRead2 :: GHC.Read.Read
                                                                                   Defs.Version)
                                                                     ($dRead1 :: GHC.Read.Read
                                                                                   Defs.Version)
                                                                     ($dRead :: GHC.Read.Read
                                                                                  GHC.Types.Bool)
  GHC.Read.$fRead(,,)_$creadsPrec @ GHC.Types.Bool
                                  @ Defs.Version
                                  @ Defs.Version
                                  $dRead
                                  $dRead1
                                  $dRead2
  = Defs.$s$fRead(,,)_$creadsPrec
"SPEC/Defs concatMap @ [] _ _" [orphan] forall @ a
                                               @ b
                                               ($dFoldable :: Data.Foldable.Foldable [])
  Data.Foldable.concatMap @ [] @ a @ b $dFoldable
  = Defs.$sconcatMap @ a @ b
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

